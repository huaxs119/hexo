<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java新特性]]></title>
    <url>%2Fhexo%2F2019%2F01%2F25%2Fjava%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[静态导入静态导入语法用于导入类的某个静态属性或者方法，使用静态导入可以简化程序对类静态属性和方法的调用 语法import static 包名.类名.静态属性|静态方法|*例如12import static java.lang.System.outimport static java.lang.Math.* 注意的事项：如果静态导入的成员与本类的成员存在同名的情况下，那么默认使用本来的静态成员，如果需要指定使用静态导入的成员，那么需要在静态成员前面加上类名12345678910111213141516import static java.lang.System.out;import static java.lang.Math.*;public class demo&#123; public static void main(String[] args)&#123; //普通写法 System.out.println("hello world"); int max = Math.max(100,200); System.out.println(max); //静态导入 out.println("hello world"); int max2 = max(100,200); out.println(max2); &#125;&#125; 增强for循环增强for循环的作用：简化迭代器的书写格式。（注意：增强for循环的底层还是使用了迭代器遍历） 增强for循环的适用范围：如果是实现了Iterable接口的对象或者是数组对象都可以使用增强for循环 增强for循环的格式123for(数据类型 变量名:遍历的目标对象)&#123;&#125; 增强for循环要注意的事项： 增强for循环底层也是使用了迭代器获取的，只不过获取迭代器由jvm完成，不需要我们获取迭代器而已，所以在使用增强for循环变量元素的过程中不准使用集合，对象对集合的元素个数进行修改 迭代器遍历元素与增强for循环变量元素的区别：使用迭代器遍历集合的元素时可以删除集合的元素，而增强for循环变量集合的元素时，不能调用迭代器的remove方法删除元素。 普通for循环与增强for循环的区别：普通for循环可以没有变量的目标，而增强for循环一定要有变量的目标 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class demo&#123; public static void main(String[] args)&#123; HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add("张三"); set.add("李四"); set.add("王五"); //使用迭代器遍历Set的集合 Iterator&lt;String&gt; it = set.iteractor(); while(it.hasNext())&#123; String temp = it.next(); System.out.println("元素："+temp); it.remove(); &#125; //使用增强for循环解决 for(String item:set)&#123; System.out.println("元素："+item); &#125; int[] arr = &#123;12,5,6,1&#125;; //普通for循环的遍历方式 for(int i = 0; i&lt;arr.length;i++)&#123; System.out.println("元素:"+item); &#125; //使用增强for循环实现 for(int item:arr)&#123; System.out.println("元素："+item) &#125; HashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put("001","张三"); map.put("002","李四"); map.put("003","王五"); map.put("004","赵六"); Set&lt;Map.Entry&lt;String,String&gt;&gt; entrys = map.entrySet(); for(Map.Entry&lt;String,String&gt; entry:entrys)&#123; System.out.println("键："+entry.getKey()+" 值："+entry.getValue()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//自定一个类使用增强for循环class MyList implements Iterator&lt;String&gt;&#123; Object[] arr = new Object[10]; int index = 0; public void add(Object o)&#123; arr[index++] = o; &#125; public int size()&#123; return index; &#125; @Override public Iterator&lt;String&gt; iterator()&#123; return new Iterator&lt;String&gt;()&#123; int cursor = 0; @Override public boolean hasNext()&#123; return cursor&lt;index; &#125; @Override public String next()&#123; return (String) arr[cursor++]; &#125; @Override public void remove()&#123; &#125; &#125;; &#125;&#125;---------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; MyList list = new MyList(); list.add("张三"); list.add("李四"); list.add("王五"); for(String item : list)&#123; System.out.println(item) &#125; &#125;&#125; 可变参数格式数据类型...变量名 注意 如果一个函数的形参使用上了可变参数之后，那么调用该方法的时候可以传递参数也可以不传递参数 可变参数实际上是一个数组对象 可变参数必须位于形参中的最后一个参数 一个函数最多只能有一个可变参数，因为可变参数要位于形参中最后一个位置上 例题定义一个函数做加法功能（函数做几个数据的加法功能是不确定）123456789101112131415public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;1,2,45,6,7&#125;; add(arr); //61 add(1,2,6,2,3,4,63,23); //104 &#125; public static void add(int...arr)&#123; int result = 0; for(int item : arr)&#123; result += item; &#125; System.out.println("总和："+result); &#125;&#125; 枚举一些方法在运行时，它需要的数据不能是任意的，而必须是一定范围内的值，可以直接使用枚举予以解决 格式123enum 类名&#123; 枚举值&#125; 123456789101112131415161718192021222324252627282930313233343536373839enum Gender&#123; man("男"),woman("女"); String value; private Gender(String value)&#123; this.value = value; &#125;&#125;----------------------------------------------------class Person&#123; private String name; private Gender sex; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public Gender getSex()&#123; return sex; &#125; public void setSex(Gender sex)&#123; this.sex = sex; &#125;&#125;----------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Person p = new Person(); p.setName("张三"); p.setSex(Gender.woman); System.out.println("姓名："+p.getName()+" 性别:"+p.getSex().value); &#125;&#125; 细节 枚举类也是一个特殊的类 枚举值默认的修饰符是public static final 枚举值就是枚举值所属的类的类型，然后枚举值是指向了本类的对象的 枚举类的结构方法默认的修饰符是private的 枚举类可以定义地址的成员变量与成员函数 枚举类可以自定义构造函数，但是构造函数的修饰符必须是private 枚举类可以存在抽象的方法，但是枚举值必须要实现抽象的方法 枚举值必须要位于枚举类的第一个语句 1234567891011121314151617181920212223242526272829303132333435enum Sex&#123; man("男")&#123; public void run()&#123; System.out.println("男人在跑。。。"); &#125; &#125;,woman("女")&#123; public void run()&#123; System.out.println("女人在跑。。。。") &#125; &#125;; //枚举值 String value; //成员变量 //构造函数 private Sex(String value)&#123; this.value = value; &#125; //成员函数 public void getValue()&#123; System.out.println("value:"+value); &#125; public abstract void run();&#125;---------------------------------------------------public class demo&#123; public static void main(Sting[] args)&#123; Sex sex = Sex.man; //获取到了枚举类的对象 sex.value = "男"; sex.getValue(); sex.run(); &#125;&#125; 123456789101112131415161718192021222324252627282930//季节枚举类enum Season&#123; spring,summer,antumn,winter;&#125;--------------------------------------------------enum Person&#123; Student,worker;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Season season = Season.summer; switch(season)&#123; case spring: System.out.println("春天..."); break; case summer: System.out.println("夏天..."); break; case antumn: System.out.println("秋天..."); break; case winter: System.out.println("冬天..."); break; &#125; &#125;&#125; 1234567891011121314151617181920public class demo&#123; public static void main(String[] args)&#123; List list = new ArrayList(); list.add("1"); list.add("4"); list.add("3"); list.add("7"); //因为2是最后一个元素了，也就是删除后没有在调用了迭代器的next方法 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); if("1".equals(s))&#123; list.remove("1"); break; &#125; &#125; System.out.println(list); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合TreeMap]]></title>
    <url>%2Fhexo%2F2019%2F01%2F25%2Fjava%E9%9B%86%E5%90%88TreeMap%2F</url>
    <content type="text"><![CDATA[双列集合———| Map 如果是实现了Map接口的集合类，具备的特点：存储的数据都是以键值对的形式存在，键不可重复，值可以重复————-| HashMap 底层也是基于哈希表实现的————-| TreeMap 也是基于红黑树（二叉树）数据结构实现的，特点：会对元素的键进行排序，存储————-| Hashtable TreeMap要注意的事项 往TreeMap添加元素的时候，如果元素的键具备自然顺序，那么就会按照键的自然顺序特性排序存储 往TreeMap添加元素的时候，如果元素的键不具备自然顺特性，那么键所属的类必须要实现Comparable接口，把键的比较规则定义在CompareTo方法上 往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性，而且键所属的类也没有实现Comparable接口，那么就必须在创建TreeMap对象的时候传入比较器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Emp&#123; //implement Comparable&lt;E&gt; String name; int salary; public Emp(String name,int salary)&#123; this.name = name; this.salary = salary; &#125; @Override public String toString()&#123; return "&#123;姓名："+this.name+" 薪水："+this.salary+"&#125;"; &#125; /* @Override public int compareTo(Emp o)&#123; return this.salary - o.salary; &#125; */&#125;---------------------------------------------------//自定义一个比较器class Mycomparator implements Comparator&lt;Emp&gt;&#123; @Override public int compare(Emp o1,Emp o2)&#123; return o1.salary - o2.salary; &#125;&#125;-----------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; /* TreeMap&lt;Character,Integer&gt; tree = new TreeMap&lt;Charactor,Integer&gt;(); tree.put('c',10); tree.put('b',2); tree.put('a',5); tree.put('h',12); System.out.println(tree); */ //创建一个自定义比较器 Mycomparator mycomparator = new Mycomparator(); TreeMap&lt;Emp,String&gt; tree = new TreeMap&lt;Emp,String&gt;(mycomparator); tree.put(new Emp("冰冰",2000),"001"); tree.put(new Emp("家宝",1000),"002"); tree.put(new Emp("习总",3000),"003"); tree.put(new Emp("克强",5000),"005"); tree.put(new Emp("才厚",5000),"008"); System.out.println(tree); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合HashMap]]></title>
    <url>%2Fhexo%2F2019%2F01%2F24%2Fjava%E9%9B%86%E5%90%88HashMap%2F</url>
    <content type="text"><![CDATA[双列集合——-| Map 如果是实现了Map接口的集合类，具备的特点：存储的数据都是以键值对的形式存在的，键不可重复，值可以重复———–| HashMap 底层也是基于哈希表实现的———–| TreeMap———–| Hashtable HashMap的存储原理往HashMap添加元素的时候，首先会调用键的hashCode方法得到的元素的哈希码值，然后经过运算就可以算出该元素在哈希表中的存储位置 情况1：如果算出来的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中 情况2：如果算出的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较，如果equals方法返回的是false，那么该元素允许被存储，那么equals方法返回的是true，那么该元素被视为重复元素，不存储 123456789101112131415161718192021222324252627282930313233343536373839class Person&#123; int id; String name; public Person(int id,String name)&#123; super(); this.id = id; this.name = name; &#125; @Override public String toString()&#123; return "&#123;编号:"+this.id+" 姓名:"+this.name+"&#125;"; &#125; @Override public boolean equals(Object obj)&#123; Person p = (Person) obj; return this.id == p.id; &#125; @Override public int hashCode()&#123; return this.id; &#125;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; HashMap&lt;Person,String&gt; map = new HashMap&lt;Person,String&gt;(); map.put(new Person(110,"张三"),"001"); map.put(new Person(220,"李四"),"002"); map.put(new Person(330,"王五"),"003"); //如果出现了相同键，那么后添加的数据的值会取代之前的值 map.put(new Person(110,"陈六"),"007"); System.out.println("集合的元素："+map); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合Map]]></title>
    <url>%2Fhexo%2F2019%2F01%2F24%2Fjava%E9%9B%86%E5%90%88Map%2F</url>
    <content type="text"><![CDATA[双列集合——| Map 如果是实现了Map接口的集合类，具备的特点：存储的数据都是以键值对的形式存在的，键不可重复，值可以重复———–| HashMap———–| TreeMap———–| Hashtable Map接口的方法添加 put(K key,V value) putAll(Map&lt;? extends k,? extends v&gt; m) 删除 remove(Object key) clear() 获取 get(Object key) size() 判断 containsKey(Object key) containsValue(Object value) 迭代 KeySet() values() entrySet() 123456789101112131415161718192021222324252627282930313233343536public class demo&#123; public static void main(String[] args)&#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //添加方法 map.put("汪峰","章子怡"); map.put("文章","马伊琍"); map.put("谢霆锋","张柏芝"); //如果之前没有存在该键，那么返回的是null，如果之前就已经存在该键了，那么就返回该键之前对应的值 System.out.println("返回值:"+map.put("谢霆锋"，"王菲")); //返回值：张柏芝 Map&lt;String,String&gt; map2 = HashMap&lt;String,String&gt;(); map2.put("杨振宁","翁帆"); map2.put("习总"，"彭总"); //把map2的元素添加到map集合中 map.putAll(map2); //删除 //根据键删除一条map中的数据，返回的是该键对应的值 System.out.println("删除的数据是："+map.remove("汪洋")); map.clear(); //清空集合中的所有数据 //获取 System.out.println("根据指定的键获取对应的值："+map.get("文章")); System.out.println("获取map集合键值对个数："+map.size()); //判断 System.out.println("判断map集合是否包含指定的键："+map.containsKey("文章")); System.out.println("判断map集合中是否包含指定的值："+map.containsValue("张柏芝")); map.clear(); System.out.println("判断map集合是否为空元素："+map.isEmpty()); System.out.println("集合的元素："+map); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class demo&#123; public static void main(String[] args)&#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //添加方法 map.put("汪峰","章子怡"); map.put("文章","马伊琍"); map.put("谢霆锋","张柏芝"); map.put("成龙","林凤娇"); //map集合中遍历方式一：使用KeySet方法进行遍历，缺点：KeySet方法只是返回了所有的键，没有值 //把Map集合中的所有键都保存到一个set类型的集合对象中返回 Set&lt;String&gt; keys = map.keySet(); Iterator&lt;String&gt; it = keys.iterator(); while(it.hasNext())&#123; String key = it.next(); System.out.println("键："+key+" 值："+map.get(key)); &#125; //map集合的遍历二：使用values方式进行比那里，缺点是values方法只能返回所有的值，没有键 //把所有的值存储到一个Collection集合中返回 Collection&lt;String&gt; c = map.values(); Iterator&lt;String&gt; it1 = c.iterator(); while(it1.hasNext())&#123; System.out.println("值："+it1.next()); &#125; //map集合的遍历方式三：entrySet方式遍历 Set&lt;Map.Entry&lt;String,String&gt;&gt; entrys = map.entrySet(); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it2 = entrys.iterator(); while(it2.hasNext())&#123; Map.Entry&lt;String,String&gt; entry = it2.next(); System.out.println("键："+entry.getKey()+" 值："+entry.getValue()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java泛型]]></title>
    <url>%2Fhexo%2F2019%2F01%2F24%2Fjava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型的好处 将运行时的异常提前到了编译时 避免了无谓的强制类型转换 泛型在集合中的常见应用ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 注意：泛型没有多态的概念，左右两边的数据类型必须要一致，或者只是写以一边的泛型类型1234567891011121314public class demo&#123; public static void main(String[] args)&#123; //&lt;String&gt; 表示该容器只能存储字符串类型的数据 ArrayList&lt;String&gt; List = new ArrayList&lt;String&gt;(); list.add("aa"); list.add("bb"); list.add("cc"); for(int i=0;i&lt;list.size();i++)&#123; String str = list.get(i); System.out.println("大写："+str.toUpperCase()); &#125; &#125;&#125; 自定义泛型就是一个数据类型的占位符或者是一个数据类型的变量 方法上自定义泛型修饰符 &lt;声明自定义的泛型&gt;返回值类型 函数名(使用自定义泛型...){} 在泛型中不能使用基本数据类型，如果需要使用基本数据类型，那么就使用基本数据类型对应的包装类型| 数据类型| 包装类型||——-|——–||byte| Byte||short|Short||int | Integer||long | Long|| | ||double|Double||float|Float|| | ||boolean|Boolean||char|Character| 泛型注意的事项 在方法上自定义泛型，这个自定义泛型的具体数据类型是在调用该方法的时候传入实参时确定具体的数据类型 自定义泛型只要符合标识符的命名规则即可，但是自定义泛型我们一般都习惯使用一个大写字母表示T TypeE Element 12345678910public class demo&#123; public static void main(String[] args)&#123; String str = getData("abc"); Integer i = getDate(123); &#125; public static &lt;abc&gt;abc getData(abc o)&#123; return o; &#125;&#125; 泛型类泛型类的定义格式: 123class 类名&lt;声明自定义泛型&gt;&#123;&#125; 注意事项： 在类上自定义泛型的具体数据类型是在使用该类的时候创建对象的时候确定的 如果一个类在类上已经声明了自定义泛型，如果使用该类创建对象的时候没有指定泛型的具体数据类型，难么默认为Object类型 在类上自定义泛型不能作用于静态的方法，如果静态的方法需要使用自定义泛型，那么需要在方法上自己声明使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyArraya&lt;T&gt;&#123; //元素翻转 public void reverse(T[] arr)&#123; for(int startIndex = 0 , endIndex = arr.length-1 ; startIndex&lt;endIndex ; startIndex++,endIndex--)&#123; T temp = arr[startIndex]; arr[startIndex] = arr[endIndex]; arr[endIndex] = temp; &#125; &#125; public String toString(T[] arr)&#123; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i&lt;arr.length;i++)&#123; if(i==0)&#123; sb.apped("&#123;"+arr[i]+","&#125;); &#125;else if(i==arr.length-1)&#123; sb.append(arr[i]+"]"); &#125;else&#123; sb.apped(arr[i]+","); &#125; &#125; return sb.toString(); &#125; public static &lt;T&gt;void print(T[] t)&#123; &#125;&#125;---------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Integer[] arr = &#123;10,12,14,19&#125;; MyArrays&lt;Integer&gt; tool = new MyArrays&lt;Integer&gt;(); tool.reverse(arr); System.out.println("数组的元素："+tool.toString(arr)); MyArrays&lt;String&gt; tool2 = new MyArrays&lt;String&gt;(); String[] arr2 = &#123;"aaa","bbb","ccc"&#125;; tool2.reverse(arr2); ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); &#125;&#125; 泛型接口定义格式123interface 接口名 &lt;声明自定义泛型&gt;&#123;&#125; 注意事项： 接口上自定义的泛型的具体数据类型是在实现一个接口的时候指定的 在接口上自定义的泛型如果在实现接口的时候没有指定具体的数据类型，那么默认为Object类型 如果需要在创建接口实现类对象的时候才指定接口上的自定义泛型，那么需要一下格式：Class&lt;T&gt; 类名 implements 接口&lt;T&gt; 123456789101112131415interface Dao&lt;T&gt;&#123; public void add(T t);&#125;-------------------------------------------------public class demo&lt;T&gt; implements Dao&lt;T&gt;&#123; public static void main(String[] args)&#123; demo&lt;String&gt; d = new demo&lt;String&gt;(); @Override public void add(T t)&#123; &#125; &#125;&#125; 泛型的上下限 定义一个函数可以接收任意类型的集合对象，要求接收的集合对象只能存储Integer或者Integer的父类类型数据 定义一个函数可以接收任意类型的集合对象，要求接收的集合对象只能存储Number或者Number的子类类型数据 通配符 ?? super Integer 只能存储Integer或者是Integer父类元素，泛型的下限 ? extends Number 只能存储Number或者是Number类型的子类数据，泛型上限 12345678910111213141516171819public class demo&#123; public static void main(String[] args)&#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Number&gt; list2 = new ArrayList&lt;Number&gt;(); HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //getData(set); &#125; //泛型的上限 public static void getData(Collection&lt;? extends Number&gt; c)&#123; &#125; //泛型的下限 public static void print(Collection&lt;? super Integer&gt; c)&#123; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合set]]></title>
    <url>%2Fhexo%2F2019%2F01%2F23%2Fjava%E9%9B%86%E5%90%88set%2F</url>
    <content type="text"><![CDATA[集合体系——–| Collection 单例集合的根接口————–| List 如果是实现了List接口的集合类，具备的特点：有序，可重复——————| ArrayList 底层是维护了一个Object数组实现的，特点：查询快，增删慢——————| LinkedList 底层是使用了链表数据结构实现的，特点：查询慢，增删快——————| Vector 底层也是维护了一个Object的数组实现的，实现与ArrayList是一样的，但是Vector是线程安全的，操作效率低————–| Set 如果是实现了Set接口的集合类，具备的特点：无序，不可重复——————| HashSet 底层是使用了哈希表来支持的，特点：存取速度快——————| TreeSet 如果元素具备自然顺序的特征，那么就按照元素自然顺序的特性进行排序存储 12345678910public class demo&#123; public static void main(String[] args)&#123; Set set = new HashSet(); set.add("王五"); set.add("李四"); set.add("张三"); System.out.println("添加成功吗？"+set.add("张三")); //false System.out.println(set); &#125;&#125; HashSet的实现原理往Hashset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 然后通过元素的哈希值经过移位等运算，就可以算出该元素在哈希表中的存储位置 情况1：如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上情况2：如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置上的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素运行添加 123456789101112131415161718192021222324252627282930313233343536373839404142class Person&#123; int id; String name; public Person(int id,String name)&#123; super(); this.id = id; this.name = name; &#125; @Override public String toString()&#123; return "&#123;编号："+this.id+" 姓名："+this.name+"&#125;"; &#125; @Override public int hashCode()&#123; System.out.println("=======hashCode========"); return this.id; &#125; @Override public boolean equals(Object obj)&#123; System.out.println("========equals=========="); Person p = (Person) obj; return this.id == p.id; &#125;&#125;-------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; HashSet set = new HashSet(); set.add(new Person(110,"张三")); set.add(new Person(220,"李四")); set.add(new Person(330,"王五")); //在现实生活中只有编号一致就为同一人 System.out.println("添加成功吗？"+set.add(new Person(110,"张三"))); System.out.println("集合的元素："+set); &#125;&#125; 接受接盘录入用户名与密码，如果用户名与密码已经存在集合中，那么就视为重复元素，不允许添加到HashSet中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class User&#123; String username; String password; public User(String username,String password)&#123; super(); this.username = username; this.password = password; &#125; @Override public String toString()&#123; return "&#123;用户名："+this.username+" 密码："+this.password+"&#125;"; &#125; @Override public boolean equals(Object obj)&#123; Uers user = (User) obj; return this.username.equals(user.username)&amp;&amp;this.password.equals(user.password) &#125; @Override public int hashCode()&#123; return username.hashCode()+password.hashCode(); &#125;&#125;---------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); HashSet set = new HashSet(); while(true)&#123; System.out.println("请输入用户名："); String username = scanner.next(); System.out.println("请输入密码："); String password = scanner.next(); //创建一个对象 User user = new User(username,password); if(set.add(user))&#123; System.out.println("注册成功。。。。。"); System.out.println("当前的用户有："+set) &#125;else&#123; System.out.println("注册失败"); &#125; &#125; &#125;&#125; TreeSet添加自定义元素12345678910public class demo&#123; public static void main(String[] args)&#123; TreeSet set = new TreeSet(); set.add('b'); set.add('f'); set.add('a'); set.add('c'); System.out.println(set); //[a,b,c,f] &#125;&#125; TreeSet要注意的事项 往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特征，那么就按照元素自然顺序的特性进行排序存储 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable接口，把元素的比较规则定义在compareTo(T o)方法上 如果比较元素的时候，compareTo方法返回的是0，那么该元素就被视为重复元素，不允许添加(注意：treeSet和HashCode、equals方法是没有任何关系) 往TreeSet添加元素的时候，如果元素本身没有具备自然顺序的特性，而元素所属的类也没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个比较器 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口，在创建TreeSet对象的时候也传入了比较器，那么是以比较器的比较规则优先使用 自定义比较器自定义一个类实现Comparator接口即可，把元素与元素之间的比较规则定义在compare方法内即可自定义比较器的格式1234class 类名 implements Comparetor&#123;&#125;推荐使用：比较器(Comparator) 123456789101112131415161718192021222324class Emp implements Comparable&lt;Emp&gt;&#123; int id; String name; int salary; public Emp(int id,String name,int Salary)&#123; super(); this.id = id; this.name = name; this.salary = salary; &#125; @Override public String toString()&#123; return "&#123;编号:"+this.id+" 姓名:"+this.name+" 薪水:"+this.salary+"&#125;"; &#125; //元素与元素之间的比较规则 //负整数、零或者正整数，根据此对象是小于、等于还是大于指定对象 @Override public int comparaTo(Emp o)&#123; return this.salary - o.salary; &#125;&#125; 12345678910111213141516171819202122232425262728293031//自定义一个比较器class MyComparator implements Comparator&lt;Emp&gt;&#123; @Override public int compare(Emp o1,Emp o2)&#123; return o1.id - o2.id; &#125; //根据第一个参数小于、等于或大于第二个参数粉笔返回负整数、零或正整数 /*@Override public int compara(Object o1,Object 2)&#123; Emp e1 = (Emp) o1; Emp e2 = (Emp) o2; return e1.id -e2.id; &#125;*/&#125;-----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; //创建一个比较器对象 MyComparator comparator = new MyComparator(); //创建TreeSet的时候传入比较器 TreeSet tree = new TreeSet(comparator); tree.add(new Emp(110,"老陆",100)); tree.add(new Emp(113,"老钟",200)); tree.add(new Emp(220,"老汤",300)); tree.add(new Emp(120,"老蔡",500)); System.out.println("集合的元素:"+tree); &#125;&#125; TreeSet是可以对字符串进行排序的，因为字符串已经实现了Comparable接口 字符串的比较规则： 情况一：对应位置有不同的字符出现，就比较的对应位置不同的字符 情况二：对应位置上的字符都一样，就比较字符串的长度 例题将字符串中的数值进行排序，例如String str = “8 10 15 5 2 7”;———-“2 5 7 8 10 15”123456789101112131415161718public class demo&#123; public static void main(String[] args)&#123; String str = "8 10 15 5 2 7"; String[] datas = str.split(" "); TreeSet tree = new TreeSet(); for(int i=0;i&lt;datas.length;i++)&#123; //字符串转int类型数据是需要使用Integer.parseInt() tree.add(Integer.parseInt(datas[i])); &#125; //遍历treeSet的元素拼接成对应的字符串 Iterator it = tree.iterator(); while(it.hasNext())&#123; System.out.print(it.next()+" "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合LinkedList]]></title>
    <url>%2Fhexo%2F2019%2F01%2F22%2Fjava%E9%9B%86%E5%90%88LinkedList%2F</url>
    <content type="text"><![CDATA[集合体系——-| Collection 单例集合的根接口————| List 如果实现了List接口的集合类，具体的特点：有序，可重复—————–| ArrayList ArrayList底层是维护了一个Object数组实现的，特点：查询速度快，增删慢—————–| LinkedList LinkedList底层是使用了链表数据结构实现的，特点：查询数据慢，增删快—————–| Vector(了解即可) 底层也是维护了一个Object数组实现，实现了ArrayList的一样的，但是vector是线程安全的，操作效率低————| Set 如果实现了set接口的集合类，具备的特点:无序，无可重复 LinkedList特有的方法方法介绍 addFirst(E e) addLast(E e) getFirst() getLast() removeFirst() removeLast() 数据结构栈主要是用于实现对栈数据结构的存储方法先进后出 push() 新增在最前面 pop() 删除最前面的 队列（双端队列）主要是为了让你们可以使用LinkedList模拟队列数据结构的存储方法先进先出offer() 新增在最后面poll() 删除最前面的 返回逆序的迭代器对象descendingIterator() 返回逆序的迭代器对象 12345678910111213141516171819202122232425262728293031323334public class demo&#123; public static void main(String[] args)&#123; LinkedList list = new LinkedList(); list.add("张三"); list.add("李四"); list.add("王五"); //把元素添加到集合的首位置上 list.addFirst("哈哈"); //把元素添加到集合的末尾处 list.addLast("呵呵"); System.out.println("获取集合中首位置的元素："+list.getFirst()); System.out.println("获取集合中末尾的元素："+list.getLast()); System.out.println("删除集合中的首位置元素并返回："+list.removeFirst()); System.out.println("删除集合中的末尾元素并返回："+list.removeLast()); list.push("湖南"); //将该元素插入集合的开头处 //移除并返回集合中的第一个元素 System.out.println("删除集合的首元素："+list.pop()); //移除并返回集合中的第一个元素 list.offer("长沙"); System.out.println("删除集合的首元素："+list.poll()); System.out.println("集合中的元素："+list); Iterator it = list.descendingIterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 使用LinkedList实现堆栈数据结构的存储方式与队列的数据结构存储方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//使用LinkedList模拟堆栈的数据结构存储方式class StackList&#123; LinkedList list; public StackList()&#123; list = new LinkedList(); &#125; //进栈 public void add(Object o)&#123; list.push(o); &#125; //弹栈：把元素删除并返回 public Object pop()&#123; return list.pop(); &#125; //获取元素个数 public int size()&#123; return list.size(); &#125;&#125;-------------------------------------------------//使用LinkedList模拟队列的存储方法class TeamList&#123; LinkedList list; public TeamList()&#123; list = new LinkedList(); &#125; public void add(Object o)&#123; list.offer(o); &#125; public Object remove()&#123; return list.pop(); &#125; //获取元素个数 public int size()&#123; return list.size(); &#125;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; TeamList list = new TeamList(); list.add("李嘉诚"); list.add("马云"); list.add("王健林"); int size = list.size(); for(int i=0;i&lt;size;i++)&#123; System.out.println(list.remove()); &#125; &#125;&#125; 笔试题说出ArrayList和Vector的区别 相同点：ArrayList与Vector底层都是使用了Object数组实现的 不同点：ArrayList是线程不同步的，操作效率高。Vector是线程同步的，操作效率低 12345678910111213141516public class demo&#123; public static void main(String[] args)&#123; Vector v = new Vector(); //添加元素 v.addElement("张三"); v.addElement("李四"); v.addElement("王五"); //迭代该集合 Enumeration e = v.elements();//获取迭代器 while(e.hasMoreElements())&#123; System.out.println(e.nextElement()); &#125; &#125;&#125; 例题使用LinkedList存储一副扑克牌，然后实现洗牌功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//扑克类class Poker&#123; String color; //花色 String num; //点数 public Poker(String color,String num)&#123; super(); this.color = color; this.num = num; &#125; @Override public String toString()&#123; return "&#123;"+color+num+"&#125;"; &#125;&#125;-------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; LinkedList pokers = createPoker(); shufflePoker(pokers); showPoker(pokers); &#125; //洗牌的功能 public static void shufflePoker(LinkedList pokers)&#123; for(int i=0;i&lt;100;i++)&#123; //随机产生两个索引值 int index1 = random.nextInt(pokers.size()); int index2 = random.nextInt(pokers.size()); //根据索引值取出两张牌，然后交换两张牌的顺序 Poker poker1 = (Poker)poker.get(index1); Poker poker2 = (Poker)poker.get(index2); pokers.set(index1,poker2); pokers.set(index2,poker1); &#125; &#125; //显示扑克牌 public static void showPoker(LinkedList pokers)&#123; for(int i=0;i&lt;pokers.size();i++)&#123; System.out.print(pokers.get(i)); //换行 if(i%10 == 9)&#123; System.out.println(); &#125; &#125; &#125; //生成扑克牌的方法 public static LinkedList createPoker()&#123; //该集合用于存储扑克对象 LinkedList list = new LinkedList(); //定义数组存储所有的花色与点数 String[] colors = &#123;"黑桃","红桃","梅花","方块"&#125;; String[] nums = &#123;"A","2","3","4","5","6","7","8","9","10","J","Q","K"&#125;; for(int i=0;i&lt;nums.length;i++)&#123; for(int j=0;j&lt;color.length;j++)&#123; list.add(new Poker(color[j],nums[i])); &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合List]]></title>
    <url>%2Fhexo%2F2019%2F01%2F22%2Fjava%E9%9B%86%E5%90%88List%2F</url>
    <content type="text"><![CDATA[集合的体系——| Collection 单例集合的根接口————| List 如果是实现了List接口的集合类，该集合类具备的特点：有序，可重复—————–| ArrayList ArrayList底层是维护了一个Object数组实现的，特点：查询速度快，增删慢什么时候使用ArrayList：如果目前的数据是查询比较多，增删比较少的时候，那么就使用ArrayList存储这批数据，比如：高校的图书馆——————| LinkedList——————| Vector————-| Set 如果是实现了Set接口的集合类，该集合类具备的特点：无序，不可重复 有序：集合的有序不是指自然顺序，而是指添加进去的顺序是一致的 List接口中的特有方法添加 add(int index,E element) addAll(int index,Collection&lt;? extends E&gt; c) 获取 get(int index) indexOf(Object o) lastIndexOf(Object o) subList(int fromIndex,int toIndex) 修改 set(int index,E element) 迭代 listIterator() 特有方法 hasPrevious() 判断是否存在上一个元素 previous() 当前指针先向上移动一个单位，然后再取出当前指针指向的元素 next() 先取出当前指针指向的元素，让后指针向下移动一个单位 123456789101112public class demo&#123; public static void main(String[] args)&#123; List list = new ArrayList(); list.add("张三"); list.add("李四"); list.add("王五"); list.add("赵六"); list.add("赵六"); System.out.println("集合的元素："+list); &#125;&#125; List接口中特有的方法具备的特点：操作的方法都存在索引值 只有List接口下面的集合类才具备索引值，其他接口下的集合类都没有索引值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class demo&#123; public static void main(String[] args)&#123; List list = new ArrayList(); list.add("张三"); list.add("李四"); list.add("王五"); list.add("赵六"); //把元素添加到集合的末尾处 list.add("赵六"); list.add(4,"王二麻子"); //把元素添加到集合中指定的索引值位置上 System.out.println("集合的元素："+list); List list2 = new ArrayList(); list2.add("本山"); list2.add("小沈阳"); list.addAll(2,list2); //把list2的元素添加到list集合指定索引值的位置上 System.out.println(list); //获取方法 System.out.println("get方法获取元素："+list.get(1)); //根据索引值获取集合中的元素 //使用get方法遍历集合的元素 for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)+","); &#125; System.out.println("找出指定元素第一次出现在集合中的索引值："+list.indexOf("本山")); System.out.println("找指定的元素最后一次出现在集合中的索引值："+list.lastIndexOf("赵六")); List sublist = list.subList(1,3); //指定开始与结束的索引值截取集合中的元素 System.out.println("子集合的元素是："+subList); list.set(3,"赵本山"); //使用指定的元素替换索引值位置的元素 System.out.println("集合的元素："+list); &#125;&#125;------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; List list = new ArrayList(); list.add("张三"); list.add("李四"); list.add("王五"); list.add("赵六"); ListIterator it = list.listIterator(); //返回的是一个List接口中特有的迭代器 while(it.hasNext())&#123; it.next(); &#125; while(it.hasPrevious())&#123; System.out.println("元素："+it.previous()); &#125; it.next(); it.next(); it.set("张三"); &#125;&#125; 迭代器的注意事项迭代器在迭代元素的过程中，不允许使用集合对象改变集合中的元素个数，如需要添加或者删除只能使用迭代器的方法进行操作 如果使用了集合对象改变集合中元素个数那么就会出现ConcurrentModificationException异常 迭代元素的过程中，迭代器创建到使用结束的时间 123456789101112131415public class demo&#123; public static void main(String[] args)&#123; List list = new ArrayList(); list.add("张三"); list.add("李四"); list.add("王五"); ListIterator it = list.listIterator(); //获取到迭代器 while(it.hasNext())&#123; System.out.println(it.next()+","); it.add("aa"); //把元素添加到当前指针指向位置 &#125; list.add("bb"); //添加到集合的末尾处 System.out.println("\r\n集合的元素："+list); &#125;&#125; ArrayList特有的方法 ensureCapacity(int min Capacity) trimToSize() 笔试题目使用ArrayList无参的构造参数创建一个对象是，默认的容量是多少？如果长度不够使用时又自动增长多少？ArrayList底层是维护了一个Object数组实现的，使用无参构造函数时，Object数组默认是10，当长度不够时，自动增长0.5倍 例题编写一个函数消除集合中重复元素，如果书号是一样就视为重复元素，要求：遍历集合的时候必须使用迭代器，get 迭代器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Book&#123; int id; String name; public Book(int id,String name)&#123; this.id = id; this.name = name; &#125; @Override public String toString()&#123; return "&#123;书号："+this.id+" 书名:"+this.name+"&#125;"; &#125; @Override public boolean equals(Object obj)&#123; Book book = (Book)obj; return this.id == book.id; &#125;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; ArrayList list = new ArrayList(); list.add(new Book(110,"java编程思想")); list.add(new Book(220,"java核心技术")); list.add(new Book(330,"深入javaweb")); list.add(new Book(110,"java神书")); ArrayList list1 = clearRepeat(list); System.out.println("新集合的元素是:"+list1); &#125; public static ArrayList clearRepeat(ArrayList list)&#123; //创建一个新的集合 ArrayList newlist = new ArrayList(); //获取迭代器 Iterator it = list.iterator(); while(it.hasNext())&#123; //从旧集合中获取元素 Book book = (Book) it.next(); if(!newlist.contain(book))&#123; //如果新集合没有包含该书籍，那么就存储到新集合中 newList.add(book); &#125; &#125; return newlist; &#125;&#125; 例题使用集合实现注册登录功能 提示用户选择功能，A（注册）,B(登录)。要求：功能选择的时候要忽略大小写 提示用户输入注册的帐号（数字）与密码。如果输入帐号已经存在集合中，提示用户重新输入。注册完毕之后，把集合中的所有用户信息打印出来。 提示用户登录的账户与密码，如果账户和密码已经存在集合中，那么登录成功，否则登录失败 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//用户class User&#123; int id; //帐号 String password; //密码 public int getId()&#123; return id; &#125; public void setId(int id)&#123; this.id = id; &#125; public String getPassword()&#123; return password; &#125; public void setPassword(String password)&#123; this.password = password; &#125; public User(int id, String password)&#123; this.id = id; this.passowrd = password; &#125; @Override public boolean equals(Object obj)&#123; User user = (User)obj; return this.id == user.id &#125; @Override public String toString()&#123; return "&#123;帐号："+this.id+" 密码:"+this.password+"&#125;"; &#125;&#125;--------------------------------------------------public class demo&#123; static Scanner scanner = new Scanner(System.in); //使用该集合保存所有的用户信息 static Collection users = new ArrayList(); public static void main(String[] args)&#123; while(true)&#123; System.out.println("请选择功能 A(注册) B(登录)"); String option=scanner.next(); if("a".equalsIgnoreCase(option))&#123; reg(); &#125;else if("b".equalsIgnoreCase(option))&#123; login(); &#125;else&#123; System.out.println("你的选择有误，请重新输入"); &#125; &#125; &#125; public static void login()&#123; System.out.println("请输入帐号："); int id = scanner.nextInt(); System.out.println("请输入密码："); String password = scannner.next(); //判断集合的用户是否存在该用户名与密码 //遍历集合的元素，查看是否存在该用户信息 //定义变量用户记录是否登录成功的信息，默认是没有登录成功的 boolean isLogin = false; Iterator it = users.iterator(); while(it.hasNext())&#123; User user = (User) it.next(); if(user.id == id &amp;&amp; user.password.equals(password))&#123; //存在该用户信息，登录成功。。。 isLogin = true; &#125; &#125; if(isLogin == true)&#123; System.out.println("欢迎登录。。。。"); &#125;else&#123; System.out.println("用户名或者密码错误，登录失败。。。"); &#125; &#125; public static void reg()&#123; User user = null; while (true)&#123; System.out.println("请输入帐号："); int id = scanner.nextInt(); //220 user = new User(id,null); //contains底层依赖了equals方法 if(users.contains(user))&#123; //如果存在 System.out.println("该帐号已经存在，请重新输入帐号"); &#125;else&#123; //不存在 break; &#125; &#125; System.out.println("请输入密码："); String password = scanner.next(); user.setPassword(password); //把User对象保存在集合中 users.add(user); System.out.println("注册成功！"); System.out.ptintln("当前注册的人员："+users); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合Collection]]></title>
    <url>%2Fhexo%2F2019%2F01%2F19%2Fjava%E9%9B%86%E5%90%88Collection%2F</url>
    <content type="text"><![CDATA[数组存储同一种数据类型的集合容器 特点 只能存储同一种数据类型的数据 一旦初始化，长度固定 数组中的元素与元素之间的内存地址是连续的 注意：Object类型的数组可以存储任意类型的数据 集合集合是存储对象数据的集合容器 集合比数组的优势 集合可以存储任意类型的对象数据，数组只能存储同一种数据类型的数据 集合的长度会发生变化，数组的长度是固定的 集合类型——–| Collection 单例集合的根接口————-| List 如果是实现了List接口的集合类，具备的特点：有序，可重复————-| Set 如果是实现了Set接口的集合类，具备特点：无序，不可重复 Collection接口中的方法增加 add(E e) 添加成功返回true，添加失败返回false addAll(Collection c) 把一个集合的元素添加到另一个集合中去删除 clear() 清除整个集合 remove(Object o) 删除任意一个元素 removeAll(Collection c) 删除与集合c相交的元素 retainAll(Collection c) 保留与集合c相交的元素 查看 size() 大小 判断 isEmpty() 是否为空 contains(Object o) 是否包含对象 containsAll(Collection&lt;?&gt; c) 是否包含c的所有元素 迭代 toArray() 把集合的元素存储到一个Object的数组中 iterator() 返回一个迭代器 迭代器的作用：就是用于抓取集合中的元素迭代器的方法：hasNext() 询问是否有元素可以遍历，如果有元素可以遍历，返回true，否则返回falsenext() 获取元素remove() 移除迭代器最后一次返回的元素 NoSuchElementException 没有元素的异常，没有元素可以被迭代了 1234567891011121314151617181920212223242526public class demo&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add("张三"); c.add("李四"); c.add("王五"); System.out.println("添加成功吗？"+c.add("陈六")); //true //创建集合 Collection c2 = new ArrayList(); c2.add("张三"); c2.add("李四"); c2.add("王五"); //把c2的元素添加到c集合中去 c.addAll(c2); //删除方法 c.clear(); //清空集合中的元素 c.remove("张三"); //指定集合中的元素进行删除，删除成功返回true，失败返回false c.removeAll(c2); //删除c集合与c2的交集元素 c.retainAll(c2); //保留c集合与c2的交集元素，其他的元素一并删除 System.out.println("查看元素个数："+c.size()); System.out.println("集合的元素："+c) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class Person&#123; int id; String name; public Person(int id,String name)&#123; this.id = id; this.name = name; &#125; @Override public String toString()&#123; return "&#123;编号:"+this.id+" 姓名:"+this.name+"&#125;"; &#125; @Override public boolean equals(Object obj)&#123; Person p = (Person)obj; return this.id == p.id; &#125; @Override public int hashCode()&#123; return this.id; &#125;&#125;----------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add("张三"); c.add("李四"); c.add("王五"); System.out.println("判断集合是否为空元素："+c.isEmpty()); System.out.println("判断集合中是否存在指定的元素："+c.contains("张三"))； //集合添加自定义元素 Collection c1 = new ArrayList(); c1.add(new Person(110,"张三")); c1.add(new Person(119,"李四")); c1.add(new Person(120,"王五")); Collection c2 = new ArrayList(); c2.add(new Person(110,"张三")); c2.add(new Person(119,"李四")); c2.add(new Person(104,"王二麻子")); System.out.println("c1集合有包含c2集合中的所有元素吗？"+c1.containsAll(c2)); //false //如果在现实生活中，只要身份证编号一致，那么就为同一个人，contains方法的内部是依赖于equals方法进行比较 System.out.println("存在改元素吗？"+c1.contains(new Person(120,"张全蛋"))); //true System.out.println("集合的元素："+c1); &#125;&#125;--------------------------------------------------public class demo2&#123; public static void main(String[] args)&#123; Collection c = new ArrayList(); c.add("张三"); c.add("李四"); c.add("王五"); //把集合中的元素全部存储到一个Object的数组中返回 Object[] arr = c.toArray(); System.out.println("数组的元素："+Arrays.toString(arr)); Collection c1 = new ArrayList(); c1.add(new Person(110,"张三")); c1.add(new Person(119,"李四")); c1.add(new Person(120,"王五")); Object[] arr1 = c1.toArray(); for(int i = 0 ; i &lt; arr1.length ; i++)&#123; Person p = (Person) arr1[i]; if(p.id == 100)&#123; System.out.println(p) &#125; &#125; &#125;&#125;------------------------------------------------public class demo3&#123; public static void mian(String[] args)&#123; c.add("张三"); c.add("李四"); c.add("王五"); c.add("陈六"); //遍历集合元素-----&gt; 方法一：可以使用toArray方法 //Object[] arr = c.toArray(); //toArray() 把集合的元素存储到一个Object的数组中返回 //for(int i = 0;i&lt;arr.length;i++)&#123; //System.out.print(arr[i]+",") //&#125; //要求使用iterator迭代器遍历 Iterator it = c.iterator(); //返回一个迭代器 疑问：iterator()方法返回的是一个接口类型，为什么接口又可以调用方法使用呢？ while(it.hasNext())&#123; //hasNext()问是否有元素可以遍历 System.out.println("元素："+it.next());//获取元素 it.remove(); //删除迭代器最后一次返回的元素 &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java网络编程]]></title>
    <url>%2Fhexo%2F2019%2F01%2F17%2Fjava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程主要用于解决计算机与计算机（手机、平板…）之间的数据传输问题 不需要基于html页面就可以达到数据之间的传输 网络通讯的三要素 IP 端口号 协议 InetAddress(IP类)常用方法 getLocalHost() 获取本机的ip地址 getByName(“IP或者主机名”) 根据一个ip地址的字符串形式或者是一个主机名生成一个IP地址对象 getHostAddress() 返回一个IP地址的字符串表示形式 getHostName() 返回计算机的主机名 端口号是没有类描述的范围 0~65535从0到1023，系统紧密绑定于一些服务1024~65535 自由使用的端口 网络通讯的协议： udp通讯协议 tcp通讯协议 1234567891011121314151617public class demo&#123; public static void main(String[] args) throws UnknownHostException&#123; //getLocalHost 获取本机的IP地址对象 InetAddress address = InetAddress.getLocalHost(); System.out.println("IP地址："+address.getHostAddress()); System.out.println("主机名："+address.getHostName()); //获取别人机器的ip地址对象 //可以根据一个IP地址的字符串形式或者是一个主机名生成一个IP地址对象 InetAddress address1 = InetAddress.getByName("DESKTOP-8J3MN5A"); System.out.println("IP地址："+address1.getHostAddress()); System.out.println("主机名："+address1.getHostName()); //根据域名获取ip InetAddress[] arr = InetAddress.getAllByName("www.baidu.com"); System.out.println(Arrays.toString(arr)); &#125;&#125; 聊天系统客户端和服务器一问一答 如果使用BufferedReader的readline方法一定要加上\r\n才能把数据写出 使用字符流一定要调用flush方法数据才能写出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//聊天的服务器public class ServDemo&#123; public static void main(String[] args) throws IOException&#123; //建立tcp的服务器 ServerSocket serverSocket = new ServerSocket(9090) //接受客户端的连接，产生一个Socket Socket socket = serverSocket.accept(); //获取到Socket的输入流对象 BuffereReader socketReader = new BuffereReader(new InputStreamReader(socket.getInputStream)); //获取到Socket输出流对象 OutputStreamWriter socketOut = new OutputStreamWriter(socket.getOutputStream()); //获取键盘的输入流对象 BufferedReader KeyReader = new BuffereReader(new InputStreamReader(System.in)); //读取客户端的数据 String line = null; while ((line = socketReader.readline())!=null)&#123; System.out.println("服务段接受到的数据："+line); System.out.println("请输入回送给客户端的数据："); line = KeyReader.readline(); socketOut.write(line+"\r\n"); socketOut.flush(); &#125; serverSocket.close(); &#125;&#125;----------------------------------------------------public class CliDemo&#123; public static void main(String[] args) throws IOExceeption&#123; //建立tcp的客户端服务 Socket socket = new Socket(InetAddress.getLocalHost(),9090); //获取socket的输出流对象 OutputStreamWriter socketOut = new OutputStreamWriter(socket.getOutputStream()); //获得socket的输入流对象 BufferedReader socketReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //获取键盘的输入流对象，读取数据 BufferedReader keyReader = new BufferedReader(new InputStreamReader(System.in)); String line = null; //不断的读取键盘录入的数据，然后把数据写出 while((line = keyReader.readline())!=null)&#123; socketOut.writer(line+"\r\n"); //刷新 socketOut.flush(); //读取服务端送回的数据 line = socketReader.readline(); System.out.println("服务端回送的数据是："+line); &#125; socket.close(); &#125;&#125; 通讯协议UDP通讯协议的特点 将数据封装为数据包，面向无连接 每个数据包大小限制在64K中 因为无连接，所以不可靠 因为不需要建立连接，所以速度快 udp通讯是不分服务端与客户端的，只分发送端和接收端 TCP通讯协议的特点 tcp是基于IO流进行数据传输的，面向连接 tcp进行数据传输的时候是没有大小限制的 tcp是面向连接，通过三次握手的机制保证数据的完整性，可靠协议 tcp是面向连接的，所以速度慢 tcp是区分客户端与服务端的 tcp协议下的socket Socket(客户端),tcp的客户端一旦启动马上要与服务端进行连接 ServerSocket(服务端类) tcp的服务端错误java.net.BindException 端口被占用 ServerSocket的使用步骤 建立tcp服务端的服务 接收客户端的连接产生一个socket 获取对应的流对象读取或者写出数据 关闭资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//服务端public class Server&#123; public static void main(String[] args) throws IOException&#123; //建立tcp的服务端，并且监听一个端口 ServerSocket serverSocket = new ServerSocket(9090); //接受客户端的连接 //accpet() 接受客户端的连接，该方法也是一个阻塞型的方法，没有客户端与其连接时，会一直等待下去 Socket socket = serverSocket.accpet(); InputStream inputStream = socket.getInputStream(); byte[] buf = new byte[1024]; int length = 0; length = inputStream.read(buf); System.out.println("服务器接收："+ new String(buf,0,length)); //获得socket输出流对象，对客户端发送数据 OutoutStream outputStream = socket.getOutputStream(); outputStream.write("客户端你好".getBytes()); //关闭资源 serverSocket.close(); &#125;&#125;-------------------------------------------------//tcp客户端public class Client&#123; public static void main(String[] args) throw IOException&#123; //建立tcp的服务 Socket socket = new Socket(InetAddress.getLocalHost(),9090); //获取到Socket的输出流对象 OutputStream outputStream = socket.getOutputStream(); //利用输出流对象把数据写出即可 outputStream.write("服务端你好".getBytes()); //获取到输入流对象，读取服务端回送的数据 InputStream inputStream = socket.getInputStream(); byte[] buf = new byte[1024]; int length = inputStream.read(buf); System.out.println("客户端接收到的数据："+ new String(buf,0,length)); //关闭资源 socket.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132//模拟Tomcat服务器public class demo extends Thread&#123; Socket socket; public demo(Socket socket)&#123; this.socket = socket; &#125; public void run()&#123; try&#123; //获取socket的输出流对象 OutputStream outputStream = socket.getOutputStream(); //把数据写在浏览器上 outputStream.write("&lt;html&gt;&lt;head&gt;&lt;title&gt;aaa&lt;/title&gt;&lt;/head&gt;&lt;body&gt;你好啊，浏览器&lt;/body&gt;&lt;/html&gt;".getBytes()); socket.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws IOException&#123; //建立tcp的服务器 ServerSocket serverSocket = new ServerSocket(8111); //不断接收客户端的连接 while(true)&#123; Socket socket = serverSocket.accept(); new demo(socket).start(); &#125; &#125;&#125; 聊天系统在java中网络通讯也称作Socket(插座)通讯，要求通讯的两台机器都必须要安装Socket 不同的协议就有不同的插座（Socket） UDP协议下的SocketDatagramSocket(udp插座服务)DatagramPacket(数据包类) DatagramPacket(buf,length,address,port) buf 发送的数据内容 length 发送数据内容的大小 address 发送的目的ip地址对象 port 端口号 发送段的使用步骤： 建立udp的服务 准备数据，把数据封装到数据包中发送，发送段的数据包要带上ip地址和端口号 调用udp的服务，发送数据 关闭资源 12345678910111213141516171819//发送端public class Sender&#123; public static void main(String[] args) throws IOException&#123; //建立udp的服务 DatagramSocket datagramsocket = new DatagramSocket(); //准备数据，把数据封装到数据包 String data = "这个是我的第一个UDP的例子。。。" //创建了一个数据包 DatagramPacket packet = new DatagramPacket(data.getBytes().data.getBytes().length,InetAddress.getLocalHost(),8012); //调用udp的服务发送数据包 datagramSocket.send(packet); //关闭资源--实际上就是释放占用的端口号 datagramSocket.close(); &#125;&#125; 接收端的使用步骤 建立udp的服务 准备空的数据包接收数据 调用udp的服务接收数据 关闭资源 123456789101112131415161718public class Receive&#123; public static void main(String[] args)&#123; //建立udp的服务，并且要监听一个端口 DatagramSocket socket = new DatagramSocket(8012); //准备空的数据包用于存放数据 byte[] buf = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(buf,buf.length); //调用udp的服务接收数据 //receive是一个阻塞型的方法，没有接收到数据包之前会一直等待，数据上就是存储到了byte的自己数组中了 socket.receive(datagramPacket); System.out.print("接收端接收到数据："+new String(buf,0,datagramPacket.getLength())); //关闭资源 socket.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public class SafeReceive&#123; public static void main(String[] args) throws IOException,InterruptedException &#123; //建立udp的服务 DatagramSocket socket = new DatagramSocket(8013); //建立空的数据包存储数据 byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf,buf.length); //不断接收数据包 while(true)&#123; socket.receive(packet); System.out.println(new String(buf,0,packet,getLength())); Thread.sleep(10); &#125; &#125;&#125;-----------------------------------------------------------public class SafeSender&#123; public static void main(String[] args) throws IOException &#123; //建立UPD的服务 DatagramSocket socket = new DatagramSocket(); //准备数据，数据封装到数据包中发送 DatagramPacket packet = null; for(int i=0;i&lt;10;i++)&#123; String data = i+"aaaaaaaaaaaaaaaaaaaa"; packet = new DatagramPacket(data.getBytes(),data.getBytes().length,InetAddress.getLocalHost(),8013); //发送数据包 socket.send(packet); &#125; //关闭资源 socketc.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ChatReceive extends Thread&#123; @Override public void run()&#123; try&#123; //建立udp的服务，要鉴定一个端口 DatagramSocket datagramSocket = new DatagramSocket(8011); //准备空的数据包存储数据 byte[] buf = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(buf,buf.length); boolean flag = true; while(flag)&#123; datagramSocket.receive(datagramPacket); //datagramPacket.getAddress() 获得对方数据包的ip地址对象 System.out.println(datagramPacket.getAddress().getHostAddress()+"说："+new String(buf,0,datagramPacket.getLength())); &#125; //关闭资源 datagtamSocket.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125;-----------------------------------------------------------public class ChatSender extends Thread&#123; @Override public void run()&#123; try&#123; //建立udp的服务 DatagramSocket socket = new DatagramSocket(); //准备数据，把数据转到数据包中发送 BufferedReader KeyReader = new BufferedReader(new InputStreamReader(System.in)); String line = null; DatagramPacket packet = null; while((line = KeyReader.readline())!=null)&#123; //把数据封装到数据包中，然后发送数据 packet = new DatagramPacket(line.getBytes(),line.getBytes().length,InetAddress.getByName("10.0.7.24"),8011); //把数据发送出去 socket.send(packet); &#125; //关闭资源 socket.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125;-----------------------------------------------------------public class ChatMain&#123; public static void main(String[] args)&#123; ChatReceive chatReceive = new ChatReceive(); chatReceive.start(); ChatSender chatSender = new ChatSender(); chatSender.start(); &#125;&#125; 案例每个网络程序都有自己所处理的特定格式数据，如果接收到的数据不符合指定的格式，那么就会被当成垃圾数据丢弃。（加密） 飞Q接收的数据格式：version:time :sender :ip :flag :content ;版本号 :时间 :发送人 :IP :发送的标识符（32） :真正的内容 在upd协议中，有一个IP地址称作为广播地址，广播地址就是主机号为255地址 给广播IP地址发送消息的时候，在同一个网络段的机器都可以接收到信息 1234567891011121314151617181920212223242526272829//使用udp协议给飞Q发送信息public class FeiQDemo&#123; public static void main(String[] args) throws IOException&#123; //建立udp的服务 DatagramSocket socket = new DatagramSocket(); //准备数据，把数据封装到数据包中 String date = getData("feiQ你好!"); DatagramPacket packet = new DatagramPacket(data.getBytes(),data.getBytes().length,InetAddress.getByName("192.168.15.255"),2425); //发送数据 socket.send(packet); //关闭资源 socket.close(); &#125; //把数据拼接成指定格式的数据 public static String getData(String content)&#123; StringBuilder sb = new StringBuilder(); sb.append("1.0:"); sb.append(System.currentTimeMillis()+":"); sb.append("习大大:"); sb.append("192.168.10.1:"); sb.append("32:"); sb.append(content); return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程]]></title>
    <url>%2Fhexo%2F2019%2F01%2F10%2Fjava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概念 进程：正在执行的程序称作为一个进程，进程复制了内存空间的划分 线程：在一个进程中负责了代码的执行，就是进程中一个执行路径 多线程：在一个进程中有多个线程同时执行不同的任务 运行任何一个java程序，jvm在运行的时候都会创建一个main线程执行main方法中的所有代码 一个java应用程序至少有两个线程，一个是主线程负责main方法代码的执行，一个是垃圾回收器线程，负责回收垃圾 多线程的好处 解决了一个进程能同时执行多个任务的问题 提高了资源的利用率 多线程的弊端 增加cpu的负担 降低了一个进程中线程的执行概率 引发了线程安全问题 出现了死锁现象 创建多线程 方法一 自定义一个类继承Thread类 重写Thread类的run方法，把自定义线程的任务代码写在run方法中main方法中的所有代码，自定义线程的任务代码就写在run方法中，自定义线程负责了run方法中的代码 创建Thread的子类对象，并且调用start方法开启线程 注意：一个线程一旦开启，那么线程就会执行run方法中的代码，run方法千万不能直接调用，直接调用run方法就相当于调用了一个普通的方法而已 1234567891011121314public class demo extends Thread&#123; @Override public void run()&#123; //把自定义线程的任务代码写在run方法中 for(int i=0;i&lt;100;i++)&#123; System.out.println("自定义线程："+getName()+i); &#125; &#125; public static void main(String[] args)&#123; //创建了自定义的线程对象 demo d = new demo(); d.start(); //调用start方法启动线程 &#125;&#125; 线程常用方法 Thread(String name) 初始化线程的名字 setName(String name) 设置线程对象名 getName() 返回线程的名字 sleep() 线程睡眠指定的毫秒数，静态方法，哪个线程执行了sleep方法代码那么就是哪个线程睡眠 currentThread() 返回当前的线程对象，静态方法，哪个线程执行就返回哪个线程的对象 getPriority() 返回当前线程对象的优先级，默认线程的优先级是5级，最大的优先级是10，最小是1 setPriority() 设置线程的优先级 12345678910111213141516171819public class demo extends Thread&#123; public demo(String name)&#123; super(name); //调用了Thread类的一个参数的构造方法 &#125; @Override public void run()&#123; System.out.println("this:"+this); System.out.println("当前线程对象："+Thread.currentThread()); for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+":"+i); try&#123; Thread.sleep(100); //Thread类的run方法没有抛出异常类型，所以子类不能抛出异常类型 &#125; catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 案例模拟3个窗口同时在售50张票 为什么50张被卖了150次 出现的原因是因为num是非静态的，非静态的成员变量数据是在每个对象中都会维护一份数据的，三个线程对象就会有三份 解决方案，把num票数共享出来给线程对象使用，使用static修饰 出现了线程安全问题 线程安全问题的解决方案：sun提供了线程同步机制让我们解决这类问题 java线程同步机制的方式 方式一：同步代码块同步代码块的格式是：1234&gt; synchronized(锁对象)&#123;&gt; 需要被同步的代码。。。&gt; &#125;&gt; 同步代码块要注意事项： 任意的一个对象都可以作为锁对象 在同步代码块中调用了sleep方法并不是释放锁对象 只有真正存在线程安全问题的时候才使用同步代码块，否则会降低效率 多线程操作锁对象必须是唯一共享的，否则无效 123456789101112131415161718192021222324252627282930313233343536373839404142class saleTicket extends Thread&#123; //票数，非静态的成员变量，非静态的成员变量数据都是在每个对象中都会维护一份数据 static int num = 50; public SaleTicket(String name)&#123; super(name); &#125; @Override public void run()&#123; while(true)&#123; //同步代码块 synchronized("锁")&#123; if(num&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"售出了第"+num+"号票"); try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123; e.printStrackTrace(); &#125; num--; &#125;else&#123; System.out.println("售罄了..."); break; &#125; &#125; &#125; &#125;&#125;-----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; //创建三个线程对象，模拟三个窗口 SaleTicket thread1 = new SaleTicket("窗口1"); SaleTicket thread2 = new SaleTicket("窗口2"); SaleTicket Thread3 = new SaleTicket("窗口3"); //开启线程售票 thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 方式二同步函数：同步函数就是使用synchronized修饰一个函数 出现线程安全问题的根本原因： 存在两个或者两个以上的线程对象，而线程之间共享着一个资源 有多个语句操作了共享资源 注意事项： 如果是一个非静态的同步函数的锁，对象是this对象，如果是静态的同步函数的锁，对象是当前函数所属的类的字节码文件(class对象) 同步函数的锁对象是固定的，不能由你来指定 推荐使用同步代码块 同步代码块的锁对象可以由我们随意指定，方便控制。同步函数的锁对象是固定的，不能由我们来指定 同步代码块可以很方便控制需要被同步代码的范围，同步函数必须是整个函数的所有代码都被同步 12345678910111213141516171819202122232425262728293031323334353637//一个银行账户5000块，两夫妻一个拿存折，一个拿着卡，开始取钱比赛，每次只能取一千块，要求不能出现线程安全问题class BankThread extends Thread&#123; static int count = 5000; public BankThread(String name)&#123; super(name); &#125; @Override public synchronized void run()&#123; while(true)&#123; synchronized("锁")&#123; if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"取走了1000块，还剩余"+(count-1000)+"元"); &#125;else&#123; System.out.println("去光了...."); &#125; &#125; &#125; &#125; //静态的函数----&gt; 函数所属的类的字节码到文件对象------&gt; BankThread.class 唯一的 public static synchronized void getMoney()&#123; &#125;&#125;---------------------------------------------public class demo&#123; public static void main(String[] args)&#123; //创建两个线程对象 BankThread thread1 = new BankThread("老公"); BankThread thread2 = new BankThread("老婆"); //调用start方法开启线程取钱 thread1.start(); thread2.start(); &#125;&#125; 死锁java中同步机制解决了线程安全问题，但是也同时引发死锁现象 原因 存在两个或两个以上的线程 存在两个或两个以上的共享资源 没有解决的方案，只能尽量避免发生 12345678910111213141516171819202122232425262728293031323334class Deadlock extends Thread&#123; public Deadlock(String name)&#123; super(name); &#125; @Override public void run()&#123; if("张三".equals(Thread.currentThread().getName()))&#123; synchronized("遥控器")&#123; System.out.println("张三拿到了遥控器，准备去拿电池！！"); synchronized("电池")&#123; System.out.println("张三拿到了遥控器与电池了，开着空调爽歪歪的吹着"); &#125; &#125; &#125;else if("李四".equals(Thread.currentThread().getName()))&#123; synchronized("电池")&#123; System.out.println("李四拿到了电池，准备去拿遥控器"); synchronized("遥控器")&#123; System.out.println("李四拿到了遥控器与电池了，开着空调爽歪歪的吹着..."); &#125; &#125; &#125; &#125;&#125;-------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Deadlock deadlock1 = new Deadlock("张三"); Deadlcok deadlock2 = new Deadlock("李四"); deadlock1.start(); deadlock2.start(); &#125;&#125; 创建多线程 方式二 自定义一个类实现Runnable接口 实现Runnable接口的run方法，把自定义线程的任务定义在run方法上 创建Runnable实现类对象 创建Thread类的对象，并且把Runnable实现类的对象作为实参传递 调用Thread对象的start方法开启一个线程 问题：Runnable实现类的对象是线程对象吗？Runnable实现类的对象并不是一个线程对象，只不过是实现了Runnable接口的对象而已。只有是Thread或者Thread的子类才是线程对象 问题：为什么要把Runnable实现类的对象作为实参传递给Thread对象呢？作用是什么？作用就是把Runnable实现类的对象的run方法作为了线程的任务代码去执行 推荐使用方式二，实现Runnable接口，原因是因为java单继承，多实现 1234567891011121314151617181920212223public class demo implements Runnable&#123; @Override public void run()&#123; System.out.println("this:"+this); System.out.println("当前线程:"+Thread.currentThread()); for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+":"+i); &#125; &#125; public static void main(String[] args)&#123; //创建Runnable实现类的对象 demo d = new demo(); //创建Thread类的对象，把Runnable实现类对象作为实参传递 //Thread类使用Targt变量记录了d对象 Thread thread = new Thread(d,"张三"); //调用thread对象的start方法开启线程 thread.start(); for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+":"+i); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435class SaleTicket implements Runnable&#123; int num = 10000; @Override public void run()&#123; while(true)&#123; synchronized("锁")&#123; if(num&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"售出了第"+num+"号票"); num--; &#125;else&#123; System.out.println("售罄了...."); break; &#125; &#125; &#125; &#125; &#125;----------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; //创建了一个Runnable实现类的对象 SaleTicket saleTicket = new SaleTicket(); //创建三个线程对象模拟三个窗口 Thread thread1 = new Thread(saleTicket,"窗口1"); Thread thread2 = new Thread(saleTicket,"窗口2"); Thread thread3 = new Thread(saleTicket,"窗口3"); //开启线程售票 thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 等待和唤醒 线程通讯：一个线程完成了自己的任务时，要通知另外一个线程去完成另外一个任务 wait() 等待，如果线程执行了wait方法，那么该线程会进入等待的状态，等待状态下的线程必须要被其他线程调用notify方法才能唤醒 notify() 唤醒，唤醒线程池等待线程其中的一个 notifyAll() 唤醒线程池所有等待线程 wait和notify方法要注意的事项 wait方法与notify方法是属于Object对象的 wait方法与notify方法必须要在同步代码块或者是同步函数中才能使用 wait方法与notify方法必须要由锁对象调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//产品类class Product&#123; //名字 String name; //价格 double price; //产品是否生产完毕的标识，默认情况是没有生产完成 boolean flag = false;&#125;--------------------------------------------------//生产者class Producer extends Thread&#123; //产品 Product p; public Producer(Product p)&#123; this.p = p &#125; @Override public void run()&#123; int i = 0; while(true)&#123; synchronized(p)&#123; if(p.flag == false)&#123; if(i%2==0)&#123; p.name="苹果"; p.price=6.5; &#125;else&#123; p.name="香蕉"; p.price=2.0; &#125; System.out.println("生产者产出了："+p.name+"价格是："+p.price); p.flag = true; i++; //唤醒消费者去消费 p.notifyAll(); &#125;else&#123; //已经生产完毕，等待消费者去消费 try&#123; p.wait(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125;----------------------------------------------------class Customer extends Thread&#123; Product p; public Customer(Product p)&#123; this.p = p; &#125;&#125;@Overridepublic void run()&#123; while(ture)&#123; synchronized(p)&#123; //产品已经生产完毕 if(p.flag == true)&#123; System.out.println("消费者消费了:"+p.name+" 价格："+p.price); p.flag = false; //唤醒生产者去生产 p.notifyAll(); &#125;else&#123; //产品还没有生产，应该等待生产者先生产 try&#123; p.wait; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;---------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; //产品 Product p = new Product(); //创建生产对象 Producer producer = new Producer(p) //创建消费者 Customer customer = new Customer(p) //调用start方法开启线程 producer.start(); producer.start(); &#125;&#125; 线程的停止 停止一个线程，我们一般都会通过一个变量去控制 如果需要停止一个处于等待状态下的线程，那么我们需要通过变量配合notify方法或者interrupt()来使用 1234567891011121314151617181920212223242526272829303132333435363738394041public class demo extends Thread&#123; boolean flag = true; public demo(String name)&#123; super(name); &#125; @Override public void run()&#123; int i = 0; while(flag)&#123; try&#123; //张三等待 this.wait(); &#125;catch(InterruptedException e)&#123; System.out.println("接收到了异常了..."); &#125; System.out.println(Thread.currentThread().getName()+":"+i); i++; &#125; &#125; public static void main(String[] args)&#123; demo d = new demo("张三"); d.setPriority(10); d.start(); for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+":"+i); //当主线程的i是80的时候停止张三线程 //d.interrupt(); d.interrupt()根本就无法停止一个线程 if(i == 80)&#123; d.flag = false; //把线程的等待状态强制清除，被清除状态的线程会收到一个InterruptedException d.interrupt(); //synchronized(d)&#123; //d.notify(); //&#125; &#125; &#125; &#125;&#125; 守护线程（后台线程）在一个进程中如果只剩下了守护线程，那么守护线程也会死亡 一个线程默认都不是守护线程，只要main线程执行完毕，后台线程也就随之消失 1234567891011121314151617181920212223242526272829303132public class demo extends Thread&#123; public demo(String name)&#123; super(name); &#125; @Override public void run()&#123; for(int i=0;i&lt;=100;i++)&#123; System.out.println("更新包目前下载"+i+"%"); if(i==100)&#123; System.out.println("更新包下载完毕，准备安装。。。。"); &#125; try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args)&#123; demo d = new demo("后台线程"); //setDaemon() 设置线程是否为守护线程，true为守护线程，false为非守护线程 d.setDaemon(true); //System.out.println("是守护线程吗？"+d.isDaemon()); //判断是否为守护线程 d.start(); for(int i=1;i&lt;=10000;i++)&#123; System.out.println(Thread.currentThread().getName()+":"+i); &#125; &#125;&#125; join方法123456789101112131415161718192021222324252627282930313233343536373839404142class Mon extends Thread&#123; @Override public void run()&#123; System.out.println("妈妈洗菜"); System.out.println("妈妈切菜"); System.out.println("妈妈准备炒菜,发现没有酱油了..."); //叫儿子去打酱油 Son s = new Son(); s.start(); try&#123; s.join(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println("妈妈继续炒菜"); System.out.println("全家一起吃饭..."); &#125;&#125;-------------------------------------------------class Son extends Thread&#123; @Override public void run()&#123; System.out.println("儿子下楼..."); try&#123; Thread.sleep(1000); &#125;catch(InterruptedException e)&#123; e.printStackTrack(); &#125; System.out.println("儿子一直往前走"); System.out.println("儿子打完酱油了"); System.out.println("上楼，把酱油给妈妈"); &#125;&#125;-----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Mon m = new Mon(); m.start(); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Math类]]></title>
    <url>%2Fhexo%2F2019%2F01%2F10%2Fjava-Math%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[数学类，主要是提供了很多的数学公式 abs(double a) 获取绝对值ceil(double a) 向上取整floor(double a) 向下取整round(float a) 四舍五入random() 产生一个随机数，大于等于0.0且小于1.0的伪随机double值 12345678910111213public class demo&#123; public static void main(String[] args) throws ParseException &#123; System.out.println("绝对值："+Math.abs(-3)); //绝对值：3 System.out.println("向上取整："+Math.ceil(3.14)); //向上取整：4.0 System.out.println("向下取整："+Math.floor(3.14)); //向下取整：3.0 System.out.println("四舍五入："+Math.round(3.54)); //四舍五入：4 System.out.println("随机数："+Math.random()); //随机数：0.6975080956197244 &#125;&#125; 案例：编写一个函数随机产生四位的验证码12345678910111213public class demo&#123; public static void main(String[] args)&#123; char[] arr = &#123;'中','国','传','a','Q','f','B'&#125;; StringBuilder sb = new StringBuilder(); Random random = new Random(); //需要四个随机数，通过随机数获取字符数组中的字符 for(int i = 0; i &lt; 4;i++)&#123; int index = random.nextInt(arr.length); //产生的随机数必须是数组的索引值范围之内的 sb.append(arr[index]); &#125; System.out.println("验证码："+sb); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Data类]]></title>
    <url>%2Fhexo%2F2019%2F01%2F10%2Fjava-Data%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[日期格式化 SimpleDateFormat 作用1：可以把日期转换为指定格式的字符串 format() 作用2：可以把一个字符转换对应的日期 parse() 123456789101112131415161718192021public class demo&#123; public static void main(String[] args) throws ParseException&#123; Calendar calendar = Calendar.getInstance(); //获取当前的时间 System.out.println("年："+ calendar.get(Calendar.YEAR)); //年：2018 System.out.println("月："+calendar.get(Calendar.MONTH)+1); //月：4 System.out.println("日："+calendar.get(Calendar.DATE)); //日：22 System.out.println("时："+calendar.get(Calendar.HOUR_OF_DAY)); //时：23 System.out.println("分："+calendar.get(Calendar.MINUTE)); //分：43 System.out.println("秒："+calendar.get(Calendar.SECOND)); //秒：55 Date date = new Date(); //获取当前的系统时间 SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss"); //使用了默认的格式创建了一个日期格式化对象 String time = dateFormat.format(date); //可以把日期转换指定格式的字符串 System.out.println("当前的系统时间："+time); //当前的系统时间：2018年04月22日 23:52:07 String birthday = "2000年12月26日 11:29:08"; Date date1 = dateFormat.parse(birthday); //指定的字符串格式必须要与SimpleDateFormat的模式要一致 System.out.println(date1); //Tue Dec 26 11:29:08 CST 2000 &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java RunTime]]></title>
    <url>%2Fhexo%2F2019%2F01%2F10%2Fjava-RunTime%2F</url>
    <content type="text"><![CDATA[RunTime该类主要代表了应用程序运行的环境 getRunTime() 返回当前应用程序的运行环境对象 exec(String command) 根据指定的路径执行对应的可执行文件 freeMemory() 返回java虚拟机中的空闲内存量，以字节为单位 maxMemory() 返回java虚拟机试图使用的最大内存量 totalMemory() 返回java虚拟机中的内存总量 1234567891011public class demo&#123; public static void main(String[] args) throws IOException,InterruptedException&#123; Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec("c:\\Windows\\notepad.exe"); Thread.sleep(3000); process.destroy(); System.out.println("Java虚拟机中的空闲内存量："+runtime.freeMemory()); //1011005480 System.out.println("Java虚拟机试图使用的最大内存量："+runtime.maxMemory()); //15237906432 System.out.println("返回Java虚拟机中的内存总量："+runtime.totalMemory()); //1027080192 &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java system系统类]]></title>
    <url>%2Fhexo%2F2019%2F01%2F10%2Fjava-system%E7%B3%BB%E7%BB%9F%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[System类主要用于偶去系统的属性数据 ##常用方法arraycopy(Object src,int srcPos,Object dest,int destPos,int length) 拷贝 src 源数组srcPos 源数组中的开始位置dest 目标数组destPos 目标数据中的起始位置length 要复制的数组元素的数量 currentTimeMillis() 获取当前系统时间exit(int status) 退出jvm，如果参数是0表示正常退出jvm，非0表示异常退出jvmgc() 建议jvm赶快启动垃圾回收器回收垃圾getenv(String name) 根据环境变量的名字获取环境变量getProperty(key) 获取系统的所有属性finalize() 如果一个对象被垃圾回收器回收的时候，会先调用对象的finalize()方法 12345678910111213141516171819202122232425262728293031323334353637383940class Person&#123; String name; public Person(String name)&#123; this.name = name; &#125; @Override Protected void finalize() throws Throwable&#123; super.finalize(); System.out.println(this.name+"被回收了..."); &#125;&#125;-----------------------------------------------public class demo &#123; public static void main(String[] args)&#123; int[] srcArr = &#123;10,12,14,16,19&#125;; int[] destArr = new int[4]; System.arraycopy(srcArr,1,destArr,0,4); System.out.println("目标数组的元素："+Arrays.toString(destArr)); //[12,14,16,19] System.out.println("当前的系统时间："+System.currentTimeMillis()) //1524409683813 System.out.println("环境变量"+System.out.getenv("JAVA_HOME")); for(int i=0;i&lt;4;i++)&#123; new Person("张三"+i); System.gc(); //建议马上启动垃圾回收器 &#125; //张三0被回收了。。。。 //张三1被回收了。。。。 //张三2被回收了。。。。 //张三3被回收了。。。。 Properties properties = System.getProgerties(); properties.list(System.out); String value = System.getProperty("os.name"); System.out.println("当前系统:"+value); //当前系统：Windows 10 &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Stringbuffer和Stringbuilder]]></title>
    <url>%2Fhexo%2F2019%2F01%2F10%2Fjava-Stringbuffer%E5%92%8CStringBuilder%2F</url>
    <content type="text"><![CDATA[字符串特点字符串是常量，他们的值在创建之后就不能更改，字符串的内容一旦发生了变化，那么马上会创建一个新的对象 字符串的内容不宜频繁修改，因为一旦修改马上就会创建一个新的对象如果需要频繁修改字符串的内容，建议使用字符串缓冲类（StringBuffer） StringBuffer就是一个存储字符的容器 StringBuffer笔试题目使用StringBuffer无参的构造函数创建一个对象时，默认的初始容量是多少？如果长度不够使用，自动增长多少倍？StringBuffer底层是依赖了一个字符数组才能存储字符数据的，该字符串数组默认的初始容量是16，如果字符数组的长度不够使用时，自动增长一倍 StringBuffer方法添加StringBuffer(“xxx”) 在创建对象的时候赋值append() 在缓冲区的尾部添加新的文本对象insert() 在指定的下标位置添加新的文本对象 删除delete(int start,int end) 根据指定的开始与结束的索引值删除对应的内容deleteCharAt(int index) 根据指定的索引值删除一个字符 修改replace(int start,int end,String str) 根据指定的开始与结束索引值替代成指定的内容reverse() 翻转字符串缓冲类的内容setCharAt(int index,char ch) 把指定索引值的字符替换指定的字符substring(int start,int end) 根据指定的索引值截取子串ensureCapacity(int minimumCapacity) 指定StringBuffer内部的字符数组长度 查看indexOf(String str,int fromIndex) 查找指定的字符串第一次出现的索引值，并指定开始查找的位置lastIndexOf(String str)capacity() 查看当前字符数组的长度length()charAt(int index)toString() 把字符串缓冲类的内容转成字符串返回 123456789101112131415161718192021222324252627282930313233343536373839404142public class demo&#123; public static void main(String[] args)&#123; StringBuffer sb = new StringBuffer(); sb.append("java"); sb.append("python"); sb.append(12); System.out.println(sb); //javapython12 sb.insert(4,"haha"); System.out.println(sb); //javahahapython12 sb.delete(4,8); //删除的时候也是包头不包尾 System.out.println(sb); //javapython12 sb.deleteCharAt(10); System.out.println(sb); //javapython2 sb.replace(2,4,"中国人"); System.out.println(sb); //ja中国人python2 sb.reverse(); System.out.println(sb); //2nohtyp人国中aj sb.setCharAt(2,'e'); System.out.println(sb); //2nehtyp人国中aj String str = sb.substring(2,6); System.out.println(str); //ehty int index = sb.indexOf("ty",2); System.out.println(index); //4 System.out.println(sb.capacity()); //16 System.out.println(sb.length()); //12 System.out.println(sb.charAt(3)); //h &#125;&#125; StringBuilder与StringBuffer的区别相同点 两个类都是字符串缓冲类 两个类的防范都是一致的不同点 StringBuffer是线程安全的，操作效率低，StringBuilder是线程非安全的，操作效率高 StringBuffer是jdk1.0出现的，StringBuilder是jdk1.5的时候出现的 推荐使用StringBuilder,因为操作效率高]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java String]]></title>
    <url>%2Fhexo%2F2019%2F01%2F09%2Fjava-String%2F</url>
    <content type="text"><![CDATA[String题目：new String(“abc”)创建了几个对象？两个对象，一个对象是位于字符串常量池，一个对象是位于堆内存中 12345678910111213141516public class demo&#123; public static void main(String[] args)&#123; String str1 = "hello"; String str2 = "hello"; String str3 = new String("hello"); String str4 = new String("hello"); System.out.println("str1==str2:"+(str1==str2)); //true System.out.println("str2==str3:"+(str2==str3)); //false System.out.println("str3==str4:"+(str3==str4)); //false System.out.println("str3.equals(str2):"+(str3.equals(str2))); //true //String类重写了Object的equals方法，比较的是两个字符串对象的内容是否一致 //"=="用于比较引用数据类型数据的时候比较的是两个对象的内存地址 //equals方法默认情况下比较的也是两个对象的内存地址 &#125;&#125; String的构造方法 String() 创建一个空内容的字符串对象String(byte[] bytes) 使用一个字节数组构建一个字符串对象String(byte[] bytes,int offset,int length) bytes:要解码的数组offset:指定从数组中哪个索引值开始解码length:要解码多个元素 String(char[] valus) 使用一个字符数组构建一个字符串String(char[] valus,int offset,int count) 使用一个字符数组构建一个字符串，指定开始的索引值，与使用字符个数String(int[] codePoints,int offset,int count)String(String original) 使用字节数组或字符数组都可以构建一个字符串对象1234567891011121314151617181920212223public class demo&#123; public static void main(String[] args)&#123; String str = new String(); byte[] buf = &#123;97,98,99&#125;; str = new String(buf); System.out.println(str); //abc str = new String(buf,1,2); System.out.println(str); //bc char[] arr = &#123;'明','天','是','圣','诞'&#125;; str = new String(arr); System.out.println(str); //明天是圣诞 str = new String(arr,3,2); System.out.println(str); //圣诞 int[] buf2 = &#123;65,66,67&#125;; str = new String(buf2,0,3); System.out.println(str); //ABC str = new String("abc"); System.out.println(str); //abc &#125;&#125; 获取方法 length() 获取字符串的长度charAt(int index) 获取特定位置的字符串（角标越界）indexOf(String str) 查找子串第一次出现的索引值，如果子串没有出现在字符串中，那么则返回-1表示lastIndexOf(String str)查找子串最后一次出现的索引值，如果子串没有出现在字符串中，那么则返回-1表示 123456789public class demo&#123; public static void main(String[] args)&#123; String str = "abc中国ab中国"; System.out.println("字符串的字符个数："+str.length()); //9 System.out.println("根据索引值获取对应的字符："+str.charAt(3)); //中 System.out.println("查找子串第一次出现的索引值："+str.indexOf("中国")); //3 System.out.println("查找子串最后一次出现的索引值："+str.lastIndexOf("中国")); //7 &#125;&#125; 判断方法 endsWith(String str) 是否以指定字符结束startWith(String str) 是否以指定字符结束contains(char Sequences) 是否包含指定序列，应用：搜索isEmpty() 是否为空equals(Object anObject) 是否相等equalsIgnoreCase(String anotherString) 忽略大小写是否相等 12345678910public class demo&#123; public static void main(String[] args)&#123; String str = "Demo.java"; System.out.println("是否以指定的字符串结束："+str.endsWith("ja")); //false System.out.println("判断字符串是否为空内容："+str.isEmpty()); //false System.out.println("判断字符串是否包含指定的内容："+str.contains("Demo")); //true System.out.println("判断两个字符串的内容是否一致："+"DEMO.JAVA".equals(str)); //false System.out.println("判断两个字符串的内容是否一致（忽略大小写）："+"DEMO.JAVA".equalsIgnoreCase(str)); //true &#125;&#125; 转换方法 toCharArray() 将字符串转换为字符数组getBytes() 将字符串转换为字节数组字节数组和字符数组、字符串他们三者之间是可以互相转换 123456789public class demo&#123; public static void main(String[] args)&#123; String str = "Demo.java"; char[] buf = str.toCharArray(); System.out.println("字符数组："+Arrays.toString(buf)); //[D,e,m,o,.,j,a,v,a] byte[] buf2 = str.getBytes(); System.out.println("字节数组："+Arrays.toString(buf2)); //[68,101,109,111,46,106,97,118,97] &#125;&#125; 其他方法 replace(String oldChar,String newchar) 替换split(String regex) 切割substring(int beginIndex) 指定开始的索引值截取子串substring(int beginIndex,int endIndex) 指定开始与结束的索引值截取子串toUpperCase() 转大写toLowerCase() 转小写trim() 去除字符串首尾的空格 123456789101112131415161718public class demo&#123; public static void main(String[] args)&#123; String str = "今天晚上不考试"; System.out.println("指定新内容替换旧的内容："+str.replace("不","要好好")); //今天晚上要好好考试 str = "大家-下-午-好"; String[] arr = str.split("-"); //[大家，下，午，好] System.out.println("字符串数组的内容："+Arrays.toString(arr)); str = "广州珠江河畔"; System.out.println("指定开始的索引值截取子串："+str.substring(2)); //珠江河畔 System.out.println("指定开始的索引值截取子串："+str.substring(2,6)); //珠江河畔 str = "abc中国"; System.out.println("转大写："+str.toUpperCase()); //ABC中国 str = "abdfSDD"; System.out.println("转小写："+str.toLowerCase()); //abdfsdd str = " 大家最近 都非常努力 "; System.out.println("去除字符串首尾的空格："+str.trim()); //大家最近 都非常努力 &#125;&#125; 案例 需求1：自己实现trim的方法 需求2：获取上传文件名”d:\20120512\day12\Demo1.java” 需求3：将字符串对象的字符反序 需求4：求一个子串在整串中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041public class demo&#123; public static void main(String[] args)&#123; String str = " hello world "; str = mytrim(str); System.out.println(str); str = "d:\\20120512\\day12\\demo1.java"; getFileName(str); str = "新中国好"; System.out.println("翻转后的字符串："+reverse(str)); str = "abcjavaabcjavaphpjava"; getCount(str,"java"); &#125;&#125;---------------------------------------------public static String mytrim(String str)&#123; //先转换成字符数组 char[] c = str.toCharArray(); //定义两个变量记录开始与结束的索引值 int start = 0; int end = str.length()-1; //确定开始的索引值 while(true)&#123; if(c[start] == ' ')&#123; start++; &#125;else&#123; break; &#125; &#125; while(true)&#123; if(c[end] == ' ')&#123; end--; &#125;else&#123; break; &#125; &#125; return str.substring(start,end+1);&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Object对象]]></title>
    <url>%2Fhexo%2F2019%2F01%2F09%2Fjava-Object%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Object类java是面向对象的语言，核心思想：找合适的对象做合适的事情 方式一：自定义类，然后通过自定义的类创建对象 方式二：sun提供了很多的类给我们使用，我们只需要认识这些类，我们就可以通过这些类创建对象 Object类是所有类的终极父类，任何一个类都继承了Object类 常用方法 toString(); 返回该对象的字符串表示，返回一个字符串用于描述该对象的重写toString之后，我们直接输出一个对象的时候，就会输出符合我们所需要的格式数据 equals(Object obj) 用于比较两个对象的内存地址，判断两个对象是否为同一个对象 hashCode() 返回该对象的哈希码值（可以把哈希码就理解成对象的内存地址） 一般我们重写了一个类的equals方法，我们都会重写他的hashCode方法 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person&#123; int id; String name; public Person(int id,String name)&#123; this.id = id; this.name = name; &#125; public Person()&#123;&#125; //目前的toString方法无法满足子类的需求，那么这时候我们就该对Object类的toString进行重写 @Override public String toString()&#123; return "编号:"+this.id+",名字:"+this.name; &#125; //Object的equals方法默认比较的是两个对象的内存地址，我目前需要比较的是两个对象的身份证 @Override public int hashCode()&#123; return this.id; &#125; @Override public boolean equals(Object obj)&#123; Person p = (Person)obj; return this.id == p.id; &#125;&#125;-------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Person p1 = new Person(110,"张三"); Person p2 = new Person(110,"李四"); //需求：在现实生活中只要两个人的身份证一致，那么就是同一个人 System.out.println("p1与p2是同一个对象吗？"+p1.equals(p2)); System.out.println("p1哈希码："+p1.hashCode()); System.out.println("p2哈希码："+p2.hashCode()); //输出toString方法定义格式 System.out.println(p1); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java访问修饰符]]></title>
    <url>%2Fhexo%2F2019%2F01%2F09%2Fjava%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[权限修饰符就是控制被修饰的成员的范围可见性 public(公共) protected(受保护) default(缺省) private(私有) 同一个类 true true true true 同一个包 true true true false 子父类 true true false false 不同包 true false false false 不同包下面只有public与protected可以访问，而且protected必须是在继承关系下才能够访问]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java包]]></title>
    <url>%2Fhexo%2F2019%2F01%2F09%2Fjava%E5%8C%85%2F</url>
    <content type="text"><![CDATA[java中的包就相当于windows文件夹 包的作用 解决类名重复产生冲突的问题 便于软件版本的发布 定义包的格式package 包名;包名全部小写 包语句要注意的事项 package语句必须位于java文件中第一个语句 如果一个类加上了包语句，那么该类的完整类名就是：包名.类名 一个java文件只能有一个包语句 导包简化书写格式：import 包名.类名;注意的细节 一个java文件中可以出现多句导包语句 *是导包语句的通配符，可以匹配任何的类名 import aa.*; 是不会作用于aa包下面的子包的推荐使用import 包名.类名;因为使用*通配符会导致结构不清晰 jar包打jar包需要使用到jdk的开发工具（jar.exe） 使用格式jar cvf jar文件的名字 class文件或者是文件夹 打jar包需要注意的事项 一个程序打完了jar之后必须要在清单文件上指定入口类：格式Main-Class:包名.类名 jar包双击运行仅对于图形化界面的程序起作用，对控制台的程序不起作用 jar文件的作用： 方便用户快速运行一个项目 提供工具类以jar包的形式给别人使用 如果使用jar包里面的类必须要先设置classpath路径]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常]]></title>
    <url>%2Fhexo%2F2019%2F01%2F08%2Fjava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常的定义java中通过类对一类不正常的现象进行描述，并封装为对象 java的异常体系包含在java.lang这个包，默认不需要导出 java异常体系|——-Throwable (实现类描述java的错误和异常)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|——Error (错误)一般不通过代码去处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|——Exception (异常)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|———RuntimeException(运行时异常)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|——— 非运行时异常 错误(Error)指的是一个合理的应用程序不能截获的严重的问题，大多数都是反常的情况。错误是JVM的一个故障（虽然可以是任何系统级别的错误）。所以，错误是很难处理的，一般的开发人员是无法处理这些错误的，比如内存溢出 Throwable类常用方法toString() 返回当前异常对象的完整类名+信息getMessage() 返回的是创建Throwable传入的字符串信息printStackTrace() 打印异常的栈信息 异常的处理123456789public class demo&#123; public static void main(String[] args)&#123; div(2,0); &#125; public static void div(int x,int y)&#123; //该代码的y值可能是0，程序会出现异常并停止 System.out.println(x/y); &#125;&#125; 方法一捕获处理12345try&#123; 可能发生异常的代码;&#125;catch(捕获的异常类型 变量名)&#123; 处理异常的代码...&#125; 捕获处理要注意的细节: 如果try块中代码除了异常经过了处理之后，那么try-catch块外面的代码可以正常执行 如果try块中出现了异常的代码，那么try块中出现异常代码后面的代码是不会执行的 一个try块后面是可以跟有多个catch块的，也就是一个try块可以捕获多种异常的类型 一个try块可以捕获多种异常的类型，但是捕获的异常类型必须从小到大进行捕捉，否则编译报错 123456789101112131415161718192021public class demo&#123; public static void main(String[] args)&#123; int[] arr = null; div(4,0,arr); &#125; public static void div(int a,int b,int[] arr)&#123; int c = 0; try&#123; c=a/b; System.out.println("数组的长度:"+arr.length); &#125;catch(ArithmeticException e)&#123; System.out.println("异常处理了..."); System.out.println("toString:"+e.toString()); &#125;catch(NullPointerException e)&#123; System.out.println("出现了空指针异常..."); &#125;catch(Exception e)&#123; System.out.println("我是急症室，包治百病！"); &#125; System.out.println("c="+c); &#125;&#125; 方法二抛出处理要注意的细节 如果一个方法的内部抛出了一个异常对象，那么必须要在方法上声明抛出 如果调用了一个声明抛出异常的方法，那么调用者必须要处理要处理异常 如果一个方法内部抛出了一个异常对象，那么throw语句后面的代码都不会执行了（一个方法遇到了throw关键字，该方法也会马上停止执行） 在一种情况下，只能抛出一种类型异常对象 throw与throws关键字 throw关键字是用于方法内部的，throws是用于方法声明上的 throw关键字是用于方法内部抛出一个异常对象的，throws关键字是用于在方法声明上声明抛出异常类型的 throw关键字后面只能有一个异常对象，throws后面一次可以声明抛出多种类型的异常。 123456789101112131415161718192021public class demo&#123; public static void main(String[] args)&#123; int[] arr = null; try&#123; div(4,0,arr); //调用了一个声明抛出异常类型的方法 &#125;catch(Exception e)&#123; System.out.println("异常出现了..."); e.printStackTrace(); &#125; &#125; public static void div(int a,int b,int[] arr) throws Exception,NullPointException&#123; if(b==0)&#123; throw new Exception(); //抛出一个异常对象.... &#125;else if(arr==null)&#123; throw new NullPointerException(); &#125; int c=a/b; System.out.println("c="+c); &#125;&#125; 自定义异常例题：模拟feiQ上线的时候，如果没有插上网线，那么就抛出一个没有插上网线的异常，如果已经插上了网线，那么就正常显示好友列表123456789101112131415161718192021222324//自定义一个没有网线的异常类class NoIpException extends Exception&#123; public NoIpException(String message)&#123; super(message); //调用了Exception一个参数的构造函数 &#125;&#125;public class demo&#123; public static void main(String[] args)&#123; String ip = "192.168.10.100"; ip = null; try&#123; feiQ(ip); &#125;catch(NoIpException e)&#123; e.printStackTrace(); System.out.println("马上插上网线"); &#125; &#125; public static void feiQ(String ip) throws NoIpException&#123; if(ip == null)&#123; throw new NoIpException("没有查网线啊"); &#125; System.out.println("正常显示好友列表..."); &#125;&#125; 运行时异常和非运行时异常运行时异常 RuntimeException如果一个方法内部抛出了一个运行时异常，那么方法上可以声明也可以不声明，调用者可以处理也可以不处理 运行时异常：RuntimeException以及RuntimeException子类，都是属于运行时异常 ClassCastException 多态中，可以使用instanceof判断，进行规避 ArithmentException 进行if判断，如果除数为0，进行了return NullPointerException 进行if判断，是否为null ArrayIndexOutOfBoundsException 使用数组length属性，避免越界 编译时异常（非运行时异常、受检异常）如果一个方法内部抛出了一个编译时异常对象，那么方法上就必须声明，而且调用者也必须要处理。throw或者try{}catch(){} 编译时异常： IOException 使用要导入包import java.io.IOException ClassNotFoundException 1234567891011121314151617181920212223//子类覆盖父类方法，父类方法抛出异常，子类的覆盖方法可以不抛出异常class Father&#123; void test() throws ClassNotFoundException&#123; //运行时异常 System.out.println("父类"); throw new ClassNotFoundException(); &#125;&#125;-------------------------------------------------class Son extends Father&#123; void test()&#123; System.out.println("子类"); //父类方法有异常，子类没有 &#125;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args)throws ClassNotFoundException&#123; Father f = new Son(); f.test(); &#125;&#125; 总结 子类覆盖父类方法是，父类方法抛出异常，子类的覆盖方法可以不抛出异常，或者抛出父类方法的异常，或者该父类方法异常的子类 父类方法抛出了多个异常，子类覆盖方法时，只能抛出父类异常的子集 父类没有抛出异常子类不可抛出异常，子类发生非运行时异常，需要进行try{}catch{}处，不能抛出 子类不能比父类抛出更多的异常 finally块必须要存在try块才能使用finally块的代码在任何情况下都会执行的，除了jvm退出的情况finally非常适合做资源释放的工作，这样可以保证资源文件在任何情况下都会被释放 try块的三种组合方式123456789101112131415161718192021222324//第一种比较适用于有异常要处理，但是没有资源要释放的try&#123; 可能发生异常的代码&#125;catch(捕获的异常类型 变量名)&#123; 处理异常的代码&#125;----------------------------------------------//第二种比较适用于既有异常要处理又要释放资源的代码try&#123; 可能发生异常的代码&#125;catch(捕获的异常类型 变量名)&#123; 处理异常的代码&#125;finally&#123; 释放资源的代码&#125;---------------------------------------------//第三种比较适用于内部抛出的是运行时异常，并且有资源要被释放try&#123; 可能放生异常的代码&#125;finally&#123; 释放资源的代码&#125; 123456789101112131415161718192021222324252627//finally释放资源的代码public class demo&#123; public static void main(String[] args)&#123; FileReader fileReader = null; try&#123; //找到目标文件 File file = new File("f:\\a.txt"); //建立程序与文件的数据通道 fileReader = new FileReader(file); //读取文件 char[] buf = new char[1024]; int length = 0; length = fileReader.read(buf); System.out.println("读取到的内容:"+new String(buf,0,length)); &#125;catch(IOException e)&#123; System.out.println("读取资源文件失败"); &#125;finally&#123; try&#123; //关闭资源 fileReader.close(); System.out.println("释放资源文件成功..."); &#125;catch(IOException e)&#123; System.out.println("释放资源文件失败..."); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内部类]]></title>
    <url>%2Fhexo%2F2019%2F01%2F08%2Fjava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类定义将类定义在另一个类的内部称为内部类1234567891011121314class Outer&#123; int num = 10; class Inner&#123; //属性 int age = 10； //内部类定义函数 public void print()&#123; System.out.println("内部类"); &#125; &#125; public void show()&#123; System.out.println("外部类"); &#125;&#125; 在一个类中，定义在类中的叫成员变量，定义在函数中的叫局部变量，那么根据类定义的位置也可以分为成员内部类和局部内部类（内部类产生的class文件为”外部类$内部类”,为了标明该内部类是属于具体哪个外部类的） 成员内部类成员内部类的访问方式 方式一：在外部类提供一个方法创建内部类的对象进行访问 方式二：在其他类直接创建内部类的对象，格式：外部类.内部类 变量名=new 外部类().new 内部类();Outer.Inner inner = new Outer().new Inner();如果是一个静态内部类，那么在其他类创建的格式：外部类.内部类 变量名=new 外部类.内部类();Outer.Inner inner=new Outer.Inner(); 内部类可以直接访问内部类的所有成员 内部类要注意的细节 如果外部类与内部类存在同名的成员变量时，在内部类中默认情况下是访问内部类的成员变量。可以通过外部类.this.成员变量名指定访问外部类的成员 私有的成员内部类只能在外部类提供一个方法创建内部类的对象进行访问，不能在其他类创建对象 成员内部类一旦出现了静态的成员，那么该类也必须使用static修饰 1234567891011121314151617181920212223242526272829//外部类class Outer&#123; //成员变量 //Outer.class文件被加载到内存的时候存在内存中。 //静态的成员数据是不需要对象存在才能访问 int x = 100; static class Inner&#123; static int i=10; public void print()&#123; System.out.println("这个是成员内部类的print方法"+i); &#125; &#125; //在外部的方法中创建了内部类的对象，然后调用内部方法 public void instance()&#123; Inner inner = new Inner(); inner.print(); &#125;&#125;-----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Outer.Inner inner = new Outer.Inner(); inner.print(); Outer outer = new Outer(); outer.instance(); &#125;&#125; 局部内部类包含在外部类的方法中的内部类称之为局部内部类。如果局部内部类访问一个局部变量，那么该局部变量必须使用final修饰 123456789101112131415161718192021222324class Outer&#123; int num = 4; class MyIn&#123; &#125; public void method(final int y)&#123; final int x=3; class Inner&#123; void show()&#123; System.out.println("show run -"+Outer.this.num); System.out.println("x="+x); System.out.println("y="+y); &#125; &#125; new Inner().show(); &#125;&#125;------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; new Outer().method(5); &#125;&#125; 匿名内部类没有类名的类就称作匿名内部类。必须存在继承或者实现关系才能使用格式 new 父类或者接口(){执行代码}一般用于实参12345678910111213141516171819202122232425262728293031323334353637abstract class Animal&#123; public abstract Animal run(); public abstract void sleep();&#125;----------------------------------------------class Outer&#123; public void print()&#123; Animal a = new Animal()&#123; //匿名内部的成员 @Override public Animal run()&#123; System.out.println("狗在跑。。。。。"); return this; &#125; @Qverride public void sleep()&#123; System.out.println("狗爬着睁开眼睛睡觉....."); &#125; public void bite()&#123; System.out.println("狗在咬人"); &#125; &#125;; a.run(); a.sleep(); &#125;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Outer outer = new Outer(); outer.print(); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多态]]></title>
    <url>%2Fhexo%2F2019%2F01%2F08%2Fjava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[什么是多态一个对象的多种状态 123456789101112131415161718192021222324252627282930313233343536373839class Father&#123; int x = 1; static int y = 2; void eat()&#123; System.out.println("开吃"); &#125; static void speak()&#123; System.out.println("小头爸爸"); &#125;&#125;---------------------------------------------class Son extends Father&#123; int x = 3; static int y = 4; void eat()&#123; System.out.println("大头儿子很能吃"); &#125; static void speak()&#123; System.out.println("大头儿子"); &#125;&#125;------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; //父类引用指向了子类对象 Father f = new Son(); System.out.println(f.x); //1 System.out.println(f.y); //2 f.eat(); //输出的是子类的 f.speak(); //输出的是父类的 &#125;&#125; 总结 当父类和子类具有相同的非静态成员变量，那么在多态下访问的是父类的成员变量 当父类和子类具有相同的静态成员变量，那么在多态下访问的就是父类的静态成员变量所以：父类和子类有相同的成员变量，多态下访问的是父类的成员变量 当父类和子类具有相同的非静态方法（就是子类重写父类的方法），多态下访问的是子类的成员方法 当父类和子类有相同的静态方法（就是子类重写父类静态方法），多态下访问的是父类的静态方法 多态体现 父类引用变量指向了子类的对象 父类引用也可以接收自己的子类对象 多态前提类与类之间有关系，继承或者实现 多态弊端提高扩展性，但只能使用父类引用指向父类的成员 多态特点非静态 编译时期，参考引用型变量所属的类是否有调用的方法，如果有编译通过，没有编译失败 运行时期，参考对象所属类中是否有调用的方法 总之成员函数在多态调用时，编译看左边，运行看右边 在多态中，成员变量的特点，无论编译和运行参考左边（引用型变量所属的类）在多态中，静态成员函数特点，无论编译和运行都参考左边 例题多态可以作为形参，接受范围更广的对象，避免函数重载过度使用 定义功能，根据输出的任何图形的面积和周长，子类重写了父类的抽象方法，多态下，会指向子类的非静态方法，多态可以作为返回值类型，获取任意图形对象，抽象类和接口都可以作为多态中的父类引用类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758abstract class MyShape&#123; public abstract double getArea(); public abstract double getlen();&#125;----------------------------------------------class Rect extends MyShape&#123; double width; double height; public Rect(double width,double height)&#123; this.width = width; this.height = height; &#125; @Override public double getArea()&#123; return width*height; &#125; @Override public double getlen()&#123; return (width+height)*2; &#125;&#125;--------------------------------------------class Circle extends Myshape&#123; public static final double PI=3.14; double radius; public Circle(double radius)&#123; this.radius = radius; &#125; @Override public double getArea()&#123; return radius*radius*PI; &#125; @Override public double getLen()&#123; return radius*PI*2; &#125;&#125;----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; print(new Rect(3,5)); print(new Circle(4)); &#125; public static void print(MyShape m)&#123; System.out.println(m.getLen()); System.out.println(m.getArea()); &#125;&#125; 多态可以作为返回值类型 获取任意一辆车对象，定义汽车类，有名字和颜色，提供有参和无参构造，有运行的行为。 定义BMW类，继承Car类，提供无参构造和有参构造（super父类构造），重写父类运行行为定义 定义benz类，继承Car类，提供无参构造和有参构造(super父类构造)，重写父类运行行为 定义BSJ类，继承Car类，提供无参构造和有参构造（super父类构造），重写父类运行行为 定义静态方法，汽车工厂，随机生产汽车，使用动态定义方法返回值 使用(int)Math.round(Math.random()*2);生成0-2之间的随机数 使用if…else判断，指定0，1，2，new不同汽车并返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public Car&#123; String name; String color; public Car()&#123; &#125; public Car(String name,String color)&#123; this.name = name; this.color = color; &#125; public void run()&#123; System.out.println("跑跑...."); &#125;&#125;---------------------------------------------class Bmw extends Car&#123; public Bmw()&#123; &#125; public Bmw(String name,String color)&#123; super(name,color); &#125; @Override public void run()&#123; System.out.println("宝马很拉风..."); &#125;&#125;---------------------------------------------class Benz extends Car&#123; public Benz()&#123; &#125; public Benz(String name,String color)&#123; super(name,color); &#125; @Override public void run()&#123; System.out.println("奔驰商务首选....."); &#125;&#125;------------------------------------------------class Bsj extends Car&#123; public Bsj()&#123; &#125; public Bsj(String name,String color)&#123; super(name,color); &#125; @Override public void run()&#123; System.out.println("泡妞首选...")； &#125;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; int x = 0; while(x&lt;100)&#123; Car c = CarFactory(); c.run(); x++; &#125; &#125; //定义静态方法，汽车工厂，随机生产汽车，使用多态定义方法返回值类型 //使用随机数，0，1，2 if 0 bsj 1 bmw 2 bz public static Car CarFactory()&#123; int x = (int)Math.round(Math.random()*3); if(x==0)&#123; return new Bmw("宝马x6","红色"); &#125;else if(x==1)&#123; return new Benz("奔驰","黑色"); &#125;else if(x==2)&#123; return new Bsj("保时捷","棕色"); &#125;else&#123; return new Benz("Smart","红色"); &#125; &#125;&#125; 抽象类和接口都可以作为多态中的父类引用类型 多态之类型转换如何在多态下，使用父类引用调用子类特有方法 基本类型转换 自动：小-&gt;大 强制：大-&gt;小类类型转换前提：继承，必须有关系 自动：子类转父类 Father f = new Son(); 强转：父类转子类 Son s = (Son)f;123456789101112131415161718192021222324252627282930313233343536class Father&#123; public void method1()&#123; System.out.println("这是父类"); &#125; public void method2()&#123; System.out.println("这是父类2"); &#125;&#125;-------------------------------------------------class Son extends Father&#123; @Override public void method1()&#123; System.out.println("这是子类1"); &#125; public void method3()&#123; System.out.println("这是子类3"); &#125;&#125;------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Father f = new Son(); f.method1(); //这是子类1 f.method2(); //这是父类2 //f.method3(); 编译报错 //多态弊端，只能使用父类引用指向父类成员。 //类类型转换 Son s = (Son)f; s.method3(); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java接口]]></title>
    <url>%2Fhexo%2F2019%2F01%2F08%2Fjava%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口的作用主要是使用来拓展定义类的功能，可以弥补java中单继承的缺点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Pencil&#123; String name; Pencil()&#123; &#125; Pencil(String name)&#123; this.name = name; &#125; void write()&#123; System.out.println("写字"); &#125;&#125;--------------------------------------------interface Eraser&#123; public static final String color = "白色"; public abstract void clean();&#125;---------------------------------------------class PencilWithEraser extends Pencil implements Eraser&#123; public PencilWithEraser()&#123; &#125; public PencilWithEraser(String name)&#123; super(name); &#125; @Override void write()&#123; System.out.println("考试专用"); &#125; @Override public void clean()&#123; System.out.println(super.name+":带橡皮的铅笔，就是好用"); &#125;&#125;-------------------------------------------public class demo&#123; public static void main(String[] args)&#123; PencilWithEraser p = new PencilWithEraser("中华2B"); p.write(); p.clean(); System.out.println(p.color); System.out.println(PencilWithEraser.color); &#125;&#125; 接口的定义格式1234interface 接口名&#123; 属性; 抽象方法;&#125; 接口中的所有属性，默认的修饰符是public static final接口中的所有方法，默认的修饰符是public abstract 接口的特点 类实现接口可以通过implements实现，实现接口的时候必须把接口中的所有方法实现，一个类可以实现多个接口 接口中定义的所有的属性默认是public static final的，即静态常量。既然是常量，那么定义的时候必须赋值 接口中定义的方法不能有方法体，接口中定义的方法默认添加public abstract 有抽象函数的不一定是抽象类，也可以是接口类 由于接口中的方法默认都是抽象的，所以不能被实例化 对于接口而言，可以使用子类来实现接口中未被实现的功能函数 如果实现类中要访问接口中的成员，不能使用super关键字。因为两者之间没有显式的继承关系，况且接口中的成员属性是静态的，可以使用接口名直接访问 接口没有构造方法12345678910111213interface A&#123; //描述接口的属性 int a = 12; //描述接口的行为 int getA();&#125;--------------------------------------------class B implements A&#123; public int getA()&#123; return A.a &#125;&#125; 接口与类接口与类之间是实现关系。非抽象类实现接口时，必须把接口里面的所有方法实现，类实现接口使用关键字implements，类与接口之间是可以多实现的（即一个类可以实现多个接口） 接口与接口接口与接口之间的关系是继承，接口可以多继承接口]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java值交换]]></title>
    <url>%2Fhexo%2F2019%2F01%2F07%2Fjava%E5%80%BC%E4%BA%A4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[基本数据类型交换1234567891011121314public class demo&#123; public static void mian(String[] args)&#123; int a=10; int b=20; System.out.println("交换前：a="+a+" b="+b); change(a,b); System.out.println("交换后：a="+a+" b="+b); &#125; public static void change(int a,int b)&#123; int temp = a; a = b; b = temp; &#125;&#125; 结果没有变化 数组类型交换12345678910111213public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;1,2,3,4,5,6&#125;; System.out.println("交换前："+ Arrays.toString(arr)); change(arr,1,3); System.out.println("交换后："+Arrays.toString(arr)); &#125; public static void change(int[] arr,int index1,int index2)&#123; int temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; &#125;&#125; 交换成功 对象的值交换12345678910111213141516171819class Test&#123; int x = 10; public Test(int x)&#123; this.x = x; &#125;&#125;-----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Test test = new Test(1); System.out.println("交换前："+test.x); change(test,2); System.out.println("交换后："+test.x); &#125; public static void change(Test test,int x)&#123; test.x=x; &#125;&#125; 交换成功 字符串的值交换1234567891011public class demo&#123; public static void main(String[] args)&#123; String str="itcast.cn"; System.out.println("交换前："+str); change(str,"baidu.com"); System.out.println("交换后："+str); &#125; public static void change(String src,String target)&#123; src = target &#125;&#125; 交换值失败]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java抽象类]]></title>
    <url>%2Fhexo%2F2019%2F01%2F07%2Fjava%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[当描述一个类的时候，如果不能确定功能函数如何定义，那么该类就可以定义为抽象类，功能函数应该描述为抽象函数1234567891011121314151617181920abstract class Animal&#123; String color; abstract void shout();&#125;-------------------------------------------class Dog extends Animal&#123; @Override void shout()&#123; System.out.println("汪汪"); &#125;&#125;----------------------------------------------class Bird extends Animal&#123; @Override void shout()&#123; System.out.println("叽叽喳喳"); &#125;&#125; 抽象类的特点 有抽象函数的类，该类一定是抽象类 抽象类中不一定要有抽象函数 抽象类不能使用new创建代码 抽象类主要为了提高代码的复用性，让子类继承来使用 编译器强制子类实现抽象类父类的为实现的方法。如果不实现，子类也要声明为抽象的 final和abstract不能同时修饰一个类 练习 定义抽象类MyShape(图形)定义抽象方法获取图形的长度和面积定义子类Rect继承父类MyShape定义自身特有的长度和宽（成员变量）实现父类未实现的函数定义子类Circle实现父类MyShape定义自身特有的半径和圆周率（使用常量）实现父类未实现的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758abstract class MyShape&#123; abstract double getLen(); abstract double getArea();&#125;----------------------------------------class Rect extends MyShape&#123; private double width; private double height; public Rect(double width,double height)&#123; this.width = width; this.height = height; &#125; @Override double getLen()&#123; return (width+height)*2; &#125; @Override double getArea()&#123; return width*height; &#125;&#125;------------------------------------------------class Circle extends MyShape&#123; public static final double PI=3.14; private double radius; public Circle(double radius)&#123; this.radius = radius; &#125; @Override double getLen()&#123; return radius*PI*2; &#125; @Override double getArea()&#123; return radius*redius*PI; &#125;&#125;-------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Rect r = new Rect(3,5); System.out.println(r.getArea()); System.out.println(r.getLen()); Circle c = new Circle(4); System.out.println(c.getArea()); System.out.println(c.getLen()); &#125;&#125; 抽象类注意细节可以没有抽象方法可以继承普通类与抽象类不能直接使用类名创建实例，但是有构造方法，构造方法是让子类进行初始化 abstract与其他修饰符的关系与final不能共存 final修饰类代表不可以继承，修饰方法不可重写 abstract修饰类就是用来被继承的，修饰方法就是用来被重写的 与static不能共存 static修饰的方法可以用类名调用 abstract修饰的方法没有具体的方法实现，所以不能直接调用 与private不能共存 private修饰的只能在本类中使用 abstract就是用来被子类进行重写的]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java继承]]></title>
    <url>%2Fhexo%2F2019%2F01%2F07%2Fjava%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承的特点 描述类和类之间的关系 降低类和类之间的重复代码 降低对象和对象之间的代码重复使用用静态变量降低类和类之间的代码重复使用的就是继承 extends关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Person&#123; String name; int age; static String country = "CN"; Person()&#123; &#125; void speak()&#123; System.out.println(name+":你好"); &#125;&#125;---------------------------------------------class Student extends Person&#123; Student()&#123; &#125; void study()&#123; System.out.println("姓名:"+name+" 年级:"+age+": 好好学习"); &#125;&#125;--------------------------------------------class Worker extends Person&#123; void work()&#123; System.out.println(name+":好好工作"); &#125;&#125;-----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Student stu = new Student(); stu.name = "jack"; stu.age = 20; stu.study(); stu.speak(); System.out.println(stu.country); System.out.println(Student.country); Worker worker = new Worker(); worker.name = "rose"; System.out.println(worker.country); worker.work(); worker.speak(); &#125;&#125; 继承细节 类名的设定，被继承的类称之为父类（基类），继承的类称之为子类 子类并不能继承父类中所有的成员 父类定义完整的成员、静态成员、非静态、构造方法。静态变量和静态方法都可以通过子类名.父类静态成员的形式调用 所有的私有成员不能继承，private修饰的成员 构造函数不能被继承 如何使用继承 不要为了使用继承而继承、工人和学生都有共性的成员，不能为了节省代码，让工人继承学生 super关键字 主要存在于子类方法中，用于指向子类对象中父类对象 访问父类的属性 访问父类的函数 访问父类的构造函数 this和super this 指向的是当前对象的调用 super 指向的是当前调用对象的父类 this和super只是能在有对象的前提下使用，不能在静态上下文使用 子类的构造函数默认第一行会调用父类无参的构造方法，隐式语句 子类可以显示调用父类的构造函数 如果没有显示的继承，那么都是自动继承Object类，Object类是所有类的父类 重写在继承中，子类可以定义和父类相同的名称且参数列表一致的函数，将这种函数称之为函数的重写。 特点 当子类重写了父类的函数，那么子类的对象如果调用该函数，一定调用的是重写过后的函数。可以通过super关键字进行父类函数的调用 继承可以是在子类增强父类的方法 细节 函数名必须相同 参数列表必须相同 子类重写父类的函数的时候，函数的访问权限必须大于等于父类的函数的访问权限，否则编译报错 子类重写父类的函数的时候，返回值类型必须是父类函数的返回值类型或该返回值类型的子类。不能返回比父类更大的数据类型 子类对象查找属性或方法时的顺序原则：就近原则如果子类的对象调用方法，默认先使用this进行查找，如果当前对象没有找打属性或者方法，则找当前对象中维护的super关键字指向的对象，如果还没有找到编译报错 重载和重写的不同 重载（overload） 在同一个类中，函数名相同，参数列表不同，与其他的无关（访问控制符，返回值类型），个数不同，顺序不同，类型不同 重写（override） 继承，函数名必须相同、参数列表必须相同。子类的返回值类型要等于或小于父类的返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Animal&#123; int x = 1; String name; void eat()&#123; System.out.println("吃东西"); &#125; void shout()&#123; System.out.println("我是动物"); &#125;&#125;----------------------------------------------class Dog extends Animal&#123; @Override void eat()&#123; System.out.println("啃骨头"); &#125; @Override void shout()&#123; System.out.println("汪汪"); &#125; void eat(String food)&#123; System.out.println("吃"+food); &#125;&#125;--------------------------------------------class Cat extends Animal&#123; @Override void eat()&#123; System.out.println("吃老鼠"); &#125; @Override void shout()&#123; System.out.println("喵喵"); &#125;&#125;-----------------------------------------------public class demo&#123; public static void mian(String[] args)&#123; Dog d = new Dog(); d.shout(); d.eat(); Cat c = new Cat(); c.shout(); c.eat(); &#125;&#125; final关键字123456789101112131415public class demo&#123; public static final double PI=3.14; public static double getArea(double r)&#123; return PI*r*r; &#125; public static double getLength(double r)&#123; return PI*r*2; &#125; public static void mian(String[] args)&#123; System.out.println(demo.PI) &#125;&#125; 常量一般用final修饰，常量名大写，必须赋值 基本数据类型，final让值不能改变 对象引用，final使其引用恒定不变，无法让其指向一个新的对象，但是对象自身却可以被修改 该关键字一般和static关键字结合使用，常量可以优先加载，不必等到创建对象的时候再初始化 final修饰类，该类为最终类，不能被继承，防止代码功能被重写 final修饰方法，该方法是最终方法，不能被重写，当类被继承，那么所有的非私有函数都将被继承，如果函数不想被子类继承并重写可以将该函数final修饰 final修饰形参，当形参被修饰为final，那么该形参所属的方法中不能被篡改，项目中主要用于一些只用来遍历位置数据的函数，将位置变量声明为final的，增强数据的安全性12345678910111213public class demo&#123; public static void main(String[] args)&#123; String[] arr=&#123;"think in java","java就业教程","java核心技术"&#125;; print(arr); &#125; public static void print(final String[] arr)&#123; //arr = null; 无法重新赋值 for(int x=0;x&lt;arr.length;x++)&#123; System.out.println(arr[x]) &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计模式]]></title>
    <url>%2Fhexo%2F2019%2F01%2F07%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式解决一个类在内存中只存在一个对象，想要保证对象的唯一 为了避免其他程序过多的建立该类对象，禁止其他程序建立该类对象 为了其他程序可以访问该类对象，在本类中自定义一个对象 方便其他程序对自定义类的对象的访问，对外提供一些访问方式 步骤 将构造函数私有化 在类中创建一个私有的本类对象 提供一个用类名调用的公有方法获取该对象 饿汉式单例实例在类装载时就构建，急切初始化。（预先加载法） 优点 线程安全 在类加载的同时已经创建好一个静态对象，调用时反应速度快 缺点资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName），那么这个实例仍然初始化 123456789101112131415161718class Single&#123; private static Single s = new Single(); private Single()&#123; System.out.println("饿汉式"); &#125; public static Single getInstance()&#123; return s; &#125;&#125;-----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Single.getInstance(); &#125;&#125; 懒汉式单例实例在第一次被使用时构建，延迟初始化 优点：避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法 缺点：懒汉式在单个线程中没有问题，但多个线程同时访问的时候就可能同时创建多个实例，而且着多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。 12345678910111213141516171819202122class Single&#123; private static Single s = null; private Single()&#123; System.out.println("懒汉式"); &#125; public static Single getInstance()&#123; if(s == null)&#123; //多个线程判断s都是null是，在执行new操作时多线程会出现重复情况 s = new Single(); &#125; return s; &#125;&#125;---------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Single.getInstance(); &#125;&#125; 模版模式解决某类事情的步骤有些是固定的，有些是会发生变化的，那么这时候我们可以为这类事情提供一个模版代码，从而提高效率 模版模式的步骤 先写出解决该类事情中其中一件的解决方案 分析代码，把会发生变化的代码抽取出来独立成一个方法，把该方法描述成一个抽象的方法 使用final修饰模块方法，防止别人重写你的模版方法 123456789101112131415161718192021222324252627abstract class MyRuntime&#123; public final void getTime()&#123; //记录开始的时间 Long startTime = System.currentTimeMillis(); code(); Long endTime = System.currentTimeMillis(); System.out.println("运行时间:"+(endTime-startTime)); &#125; public abstract void code();&#125;----------------------------------------------public class demo extends MyRuntime&#123; public static void main(String[] args)&#123; demo2 d = new demo2(); d.getTime(); &#125; //code方法内部就写要计算运行时间的代码 @Override public void code()&#123; int i = 0; while(i&lt;100)&#123; System.out.println("i="+i); i++; &#125; &#125;&#125; 案例定义一个函数清除该数组的重复元素，返回的数组存储了那些非重复的元素而且数组不准浪费长度 分析：确定新数组的长度 原数组的长度-重复元素个数 12345678910111213141516171819202122232425262728293031323334353637383940414243public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;11,2,4,2,10,11,2&#125;; arr = clearRepeat(arr); System.out.println("清除重复元素的数组："+Arrays.toString(arr)); &#125;&#125;-------------------------------------------------public static int[] clearRepeat(int[] arr)&#123; //先计算出重复元素的格式 //记录重复元素的个数 int count = 0; for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=i+1;j&lt;arr.length;j++)&#123; if(arr[i] == arr[j])&#123; count++; break; &#125; &#125; &#125; //新数组的长度 int newLength = arr.length - count; //创建一个新的数组 int[] newArr = new int[newLength]; int index = 0; //新数组的索引值 //遍历旧数组 for(int i=0;i&lt;arr.length;i++)&#123; int temp = arr[i]; //旧数组中的元素 boolean flag = false; //默认不是重复元素 for(int j=0;j&lt;newArr.length;j++)&#123; if(temp == newArr[j])&#123; flag = true; break; &#125; &#125; if(flag==false)&#123; newArr[index++] = temp; &#125; &#125; return newArr;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java static关键字]]></title>
    <url>%2Fhexo%2F2019%2F01%2F07%2Fjava-static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[内存分析 栈、堆、共享区Demo.class加载进共享区main方法进栈 Person p1 = new Person();Person.class 加载进方法区堆内存开辟空间，实例变量进行默认初始化，显示初始化内存地址给变量p1，栈和堆建立连接 为了让所有对象都共享一个变量，可以尝试将变量放入共享区使用static实现对象之间重复属性的数据共享 主要用于修饰类的成员 成员变量非静态成员变量：需要创建对象来访问静态成员变量：使用类名直接调用，也可以通过对象访问 1234567891011121314151617181920212223242526272829303132class Person&#123; String name; int age; String gender; static String country = "CN"; Person(String name,int age,String gender)&#123; this.name = name; this.age = age; this.gender = gender; &#125; Person()&#123; &#125; public void speak()&#123; System.out.println("国籍："+country+" 姓名："+name+" 性别："+gender+" 年龄："+age+" 哈哈！！"); &#125;&#125;------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; //访问静态成员 //直接通过类名来调用 String country = Person.country; System.out.println(country); //通过对象.成员的形式访问 Person p1 = new Person("jack",20,"男"); p1.speak(); &#125;&#125; 成员方法 可以使用类名直接调用 静态函数： 静态函数中不能访问非静态成员变量，只能访问静态变量 静态方法不可以定义this/super关键字 非静态函数：非静态函数中可以访问静态成员变量 12345678910111213141516171819202122232425262728293031class Person&#123; String name; int age; String gender; //static修饰成员变量 static String country = "CN"; Person(String name,int age,String gender)&#123; this.name = name; this.age = age; this.gender = gender; &#125; Person()&#123; &#125; //非静态方法可以访问静态成员 public void speak()&#123; System.out.println("国籍："+country+" 姓名："+name+" 性别："+gender+" 年龄："+age+" 哈哈！！！"); &#125; //静态方法 static void run()&#123; //静态方法只能访问静态成员变量 System.out.println("国籍"+country); //静态方法访问非静态成员变量，编辑报错 //System.out.println("姓名"+name); //静态方法中不可以出现this,编译报错 //this.speak(); &#125;&#125; 为什么静态函数中不能访问非静态成员static修饰的成员在共享区中，优先于对象存在 static的特点 随着类的加载而加载，随着类的消失而消失 优先于对象存在 被所有实例（对象）共享 可以直接被类名调用 静态变量（类变量）和实例变量的区别存在位置 类变量随着类的加载而加载，存在于方法区中 实例变量随着对象的建立而存在与堆内存中生命周期 类变量生命周期最长，随着类的消失而消失 实例变量生命周期随着对象的消失而消失 静态优缺点优点：对对象的共享数据进行单独空间的存储，节省空间缺点：生命周期过长，访问出现局限性（静态只能访问静态） 什么时候定义静态变量当对象中出现共享数据 什么时候定义静态函数如果功能内部没有访问到非静态数据（对象的特有数据），那么该功能就可以定义为静态 静态的应用自定义数组工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Arrays&#123; private Arrays()&#123; &#125; //定义一个遍历数组的函数 public static void print(int[] arr)&#123; for(int x=0;x&lt;arr.length;X++)&#123; if(x!=(arr.length-1))&#123; System.out.println(arr[x]+","); &#125;else&#123; System.out.println(arr[x]); &#125; &#125; &#125; //定义一个求数组和的功能函数 public static int getSum(int[] arr)&#123; int sum = 0; for(int x=0;x&lt;arr.length;x++)&#123; sum += arr[x]; &#125; return sum; &#125; //定义一个获取数组最大值的功能函数 public static int getMax(int[] arr)&#123; int max = 0; for(int x=0;x&lt;arr.length;x++)&#123; if(arr[max]&lt;arr[x])&#123; max=x; &#125; &#125; return max; &#125; //定义一个返回，指定数在指定数组中包含的角标的功能函数 public static int getIndex(int[] arr,int src)&#123; int index = 0; for(int x = 0;x&lt;arr.length;x++)&#123; if(arr[x]==src)&#123; index=x; &#125; &#125; return index; &#125; //冒泡 public static void test(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp = arr[j]; arr[j] =arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125; //选择排序 public static void selectSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j = i+1;j&lt;arr.length;j++)&#123; if(arr[i]&gt;arr[j])&#123; int temp = arr[i] arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; //定义一个可以叫将整数数组镜像反序的功能函数 public static void reverseSort(int[] arr)&#123; for(int start = 0,end = arr.length-1;start&lt;end;start++,end--)&#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; //二分法查找 public static int halfSearch(int[] arr,int x)&#123; int start = 0; int end = arr.length-1; int middle = 0; while(start&lt;=end)&#123; middle = (start+end)/2; if(x&gt;arr[middle])&#123; start=middle+1; &#125;else if(x&lt;arr[middle])&#123; end = middle; &#125;else&#123; return middle; &#125; &#125; return -1; &#125;&#125;----------------------------------------------public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;2,45,1,32,46,3,34,43,12,34,2,6,34,8&#125;; Arrays.test(arr); System.out.println(java.util,Arrays.toString(arr)); int x = Arrays.halfSearch(arr,46); System.out.println(x); &#125;&#125; main方法主函数是静态的public static void main(String[] args{}主函数是一个特殊的函数，作为程序的入口，可以被jvm识别 主函数的定义：public 代表函数的访问权限是最大的static 代表主函数随着类的加载，就已经存在void 主函数没有具体的返回值main 不是关键字，是一个特殊的单词可以被jvm识别String[] args 函数参数，参数类型是一个数组，该数组中的元素是字符串，字符串类型的数组]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java构造方法]]></title>
    <url>%2Fhexo%2F2019%2F01%2F07%2Fjava%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[构造方法的作用对对象进行初始化123456789101112class Person&#123; String name; //名字 int age; //年龄 //全参构造方法 Person(String name,int age)&#123; this.name = name; //给对象赋予name值 this.age = age; //给对象赋予age值 &#125; Person()&#123; &#125;&#125; 构造函数与普通函数的区别 一般函数是用于定义对象应该具备的功能。而构造函数定义的是，对象在调用功能之前，在建立时，应该具备的一些内容。也就是对象的初始化内容。 构造函数是在对象建立时由jvm调用，给对象初始化。一般函数是对象建立后，当对象调用该功能时才会执行。 普通函数可以使用对象多次调用，构造函数就在创建对象时只要符合标识符的命名规则即可 构造函数的函数名要与类名一样，而普通的函数只要符合标识符的命名规则即可 构造函数没有返回值类型 构造函数注意的细节 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数 在一个类中可以定义多个构造函数，以进行不同的初始化。多个构造函数存在于类中，是以重载的形式体现的 构造代码块给所有的对象进行统一的初始化1234567891011121314151617181920class Person&#123; String name; int age; &#123; cry(); //每个Person对象创建出来的都会执行这里的代码 &#125; Person(String name,int age)&#123; this.name = name; this.age = age; &#125; Person()&#123; &#125; public void cry()&#123; System.out.println("哇哇..."); &#125;&#125; 作用：给对象进行初始化，对象一建立就运行并优于构造函数区别： 构造代码块是给所有对象进行统一初始化，构造函数给对应的对象初始化 构造代码块就是对构造方法中公共的信息进行提取 this关键字代表是对象的引用，也就是this在指向一个对象，所指向的对象就是调用该函数的对象引用]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java对象]]></title>
    <url>%2Fhexo%2F2019%2F01%2F05%2Fjava%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象一种以事务为中心的编程思想，将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重要性、灵活性和扩展性 类的定义1234567class Car&#123; String color; //成员变量 int num; //成员变量 void run()&#123; //成员函数 System.out.println(color+"的车，轮胎数:"+num+"个，跑起来了"); &#125;&#125; 对象的创建java中创建对象，使用new关键字，在堆内存中开辟了空间，产生了一个实体123456789public class demo&#123; public static void main(String[] args)&#123; Car c = new Car(); //为了方便使用生产的汽车，就起了一个名字。 //那么c是什么类型，是Car类型，叫做类类型变量 //注意c是持有的引用，新生产的汽车并没有直接赋值给c，持有的只是一个引用，c就像电视遥控器一样 c.run &#125;&#125; 成员对象的调用 成员变量 成员方法123456public class demo&#123; Car c = new Car(); c.color = "黑色"; //成员变量 c.num = 12; c.run(); //成员方法&#125; 局部变量和成员变量的区别 定义的位置上区别： 成员变量是定义在方法之外，类之内的 局部变量是定义在方法之内 作用上的区别： 成员变量的作用是用于描述一类事务的公共属性的 局部变量的作用就是提供一个变量给方法内部使用而已 生命周期区别： 随着对象的创建而存在，随着对象的消失而消失 局部变量在调用了对应的方法时执行到了创建该变量的语句时存在，局部变量一旦出了自己的作用域，马上从内存中消失 初始值的区别 成员变量是有默认的初始值 局部变量是没有默认的初始值的，必须要先初始化才能使用 匿名对象没有名字的实体，也就是该试听没有对应的变量名引用 用途： 当对象方法进行一次调用的时候 匿名对象可以实际参数进行传递 例如 new Car().run();12345678910111213141516171819202122232425262728293031323334class Car&#123; String color = "red"; String name = "smart"; int num = 4; void run()&#123; System.out.println(name+":"+color+":"+num+":跑起来了"); &#125;&#125;-------------------------------------------class BlackCarFactory&#123; String name; String addr; Car repairCar(Car c)&#123; c.num = 3; c.color = "黑色"; System.out.println("改装成功啦...."); return c; &#125;&#125;--------------------------------------------public class demo&#123; public static void main(String[] args)&#123; BlackCarFactory blackCarFactory = new BlackCarFactory(); blackCarFactory.name = "幸福修理厂"; blackCarFactory.addr = "天河区"; //作为实际参数传递 Car car = blackCarFactory.repairCar(new Car()); car.run(); //只使用一次 new Car().run(); &#125;&#125; 例题目前存在数组：int[] arr = {0,0,12,1,0,4,6,0}，编写一个函数接收该数组，然后把该数组的0清空，然后返回一个不存在0元素的数组步骤：1.计算新数组的长度，原来的数组长度减去0的个数 12345678910111213141516171819202122232425262728class demo&#123; public static void mian(String[] args)&#123; int[] arr = &#123;0,0,12,1,0,4,6,0&#125;; arr = clearZero(arr); System.out.println("数组的元素："+Arrays.toString(arr)); &#125; public static int[] clearZero(int[] arr)&#123; //统计0的个数 int count = 0;//定义一个变量记录0的个数 for(int i=0;i&lt;arr.length;i++)&#123; if(arr[i]==0)&#123; count++; &#125; &#125; //创建一个新的数组 int[] newArr = new int[arr.length-count]; int index = 0;//新数组使用的索引值 for(int i = 0;i &lt; arr,length;i++)&#123; if(arr[i]!=0)&#123; newArr[index] = arr[i]; index++; &#125; &#125; return newArr; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3基础及数据类型]]></title>
    <url>%2Fhexo%2F2019%2F01%2F05%2Fpython3%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[变量将一些运算的中间结果暂存到内存中，以便后续代码的调用 变量名只能是字母、数字或下划线的任意组合，第一个字符不能是数字1name = "变量" #声明变量 常量指不变的量，常量名全部是大写 数据类型 整数型 int 字符串型 str 布尔型 bool 列表 list 元组 tuple 字典 dict 集合 set 查看数据类型 type() intbin() 转换为二级制bit_length() 转换成二进制的位数 123num = 56print(bin(num)) #0b111000print(num.bit_length()) #6 boolTrue和Falses=”” 空字符串转换成bool就是False非空字符都是Truewhile的条件可以写成12while 1: xxx str字符串的索引与切片索引 s[0] 第一个字符 、s[-1] 最后一个字符切片 s[0:3] 包头不包尾&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[0:] 整个字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[:] 整个字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[0:-1] 从开始到倒数第二个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[0:5:2] 从索引为0到4，步长为2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[4:0:-1] 从索引4到1，倒过来&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[4::-1] 从索引4到0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[::-1] 从索引最后一位到第一位 123456789a = "alexa"print(a[0:3]) #aleprint(a[0:]) #alexaprint(a[:]) #alexaprint(a[0:-1]) #alexprint(a[0:5:2]) #aeaprint(a[4:0:-1]) #axelprint(a[4::-1]) #axelaprint(a[::-1]) #axela 12345678910111213141516171819202122232425262728a = "alexa"b = "How"c = "how are you"d = " asa ss "e = ['aa','ll','ee','xx']f = "how\tare\tyou"print(a.capitalize()) #首字母大写 Alexaprint(a.upper()) #全部变成大写 ALEXAprint(a.lower()) #全部变成小写 alexaprint(b.swapcase()) #大小写转换 hOWprint(c.title()) # 空格或特殊字符隔开的单词首字母大写 How Are Youprint(a.center(8,'*')) #根据给定的宽度居中，超出字符串部分用指定符号填充，默认为空格 *alexa**print(f.expandtabs(3)) #指定\t代表多少个空格 how are youprint(len(c)) #字符串长度 11print(a.startswith("a")) #是否是以指定字符开头 Trueprint(a.endswith("c")) #是否是以指定字符结尾 Falseprint(c.find("ow")) #判断是否包含指定字符，找到返回第一个字母索引，找不到返回-1 1print(c.index("ow")) #判断是否包含指定字符，找到返回第一个字母索引，找不到报错 1print(d.strip()) #默认删除前后空格，可以指定删除的字符，例如s.strip('%*') 删除前后的%和* asa ssprint(d.lstrip()) #删除前面的print(d.rstrip()) #删除后面的print(c.count("o")) #统计指定字符出现的次数 2print(d.split()) #将字符串按规定的方式分割，默认空格，返回列表print(c.replace("are","is")) #替换 how is youprint(b.isalnum()) #是否是字母或者数字组成 Trueprint(b.isalpha()) #是否是字母组成 Trueprint(b.isdigit()) #是否是数字组成 Falseprint("".join(e)) #按指定方式连接列表的元素，返回字符串 aalleexx list索引和切片方式同字符串相同12345678910111213li = ['john','alex','eric']li2 = [1,2,3]li.append('jack') #增加 ['john', 'alex', 'eric', 'jack']li.insert(1,'ali') #插入指定位置 ['john', 'ali', 'alex', 'eric', 'jack']li.extend(li2) #增加可迭代的对象 ['john', 'ali', 'alex', 'eric', 'jack', 1, 2, 3]li.pop(1) #删除指定索引位置元素，并返回删除的元素，默认为空删除最后一个元素 ['john', 'alex', 'eric', 'jack', 1, 2, 3]li.remove('jack') #删除指定值的元素 ['john', 'alex', 'eric', 1, 2, 3]li.clear() #清空列表del li #删除列表del li2[0:2] #删除指定范围的元素 [3]li2[0] = 'hello' #修改指定索引位置元素for i in li2: #循环查找列表元素 print(i) 1234567li = ['john','alex','eric']print(len(li)) #元素个数 3print(li.count("alex")) #统计指定元素出现次数 1print(li.index("alex")) #查找指定元素的索引位置 1li.sort() #正向排序 ['alex', 'eric', 'john']li.sort(reverse=True) #逆向排序 ['john', 'eric', 'alex']li.reverse() #反转顺序 ['eric', 'alex', 'john'] 12li = ['a','b',['x','y'],'c','d']print(li[2][0]) #列表的嵌套 x tuple元组就是只读的列表1tu = (21,24,42,112,55) dict]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python流程控制]]></title>
    <url>%2Fhexo%2F2019%2F01%2F05%2Fpython%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[if流程控制if12if 条件: 执行的代码 if…else1234if 条件: 执行的代码1else: 执行的代码2 if…elif…else12345678if 条件1: 执行的代码1elif 条件2: 执行的代码2elif 条件3: 执行的代码3else: 执行的代码4 while循环12while 条件: 循环体 循环终止语句 break 结束整个循环，跳出循环体执行后面的语句 continue 终止本次循环，跳出下一次循环 while…else1234while 条件: 循环体 #只要没有被break终止就会执行elseelse: 循环正常完成后执行的语句 for循环12for i in s: print(i) range() 生产可迭代的范围12345678for i in range(10): #0~9 print(i)for i in range(4,10): #4~9 print(i)for i in range(0,10,3): #0,3,6,9 print(i)]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle11g安装(centos6)]]></title>
    <url>%2Fhexo%2F2019%2F01%2F04%2Foracle11g%E5%AE%89%E8%A3%85-centos6%2F</url>
    <content type="text"><![CDATA[关闭防火墙123service iptables statusservice iptables stopchkconfig iptables off 关闭selinuxvim /etc/selinux/config 设置网络vim /etc/hosts 上传安装包上传oracle安装包并解压12unzip linux.x64_11gR2_database_1of2.zipunzip linux.x64_11gR2_database_2of2.zip 安装linux工具包linux6系统 yum install -y binutils-2.20.51.0.2-5.11.el6 compat-libcap1-1.10-1 compat-libstdc++-33-3.2.3-69.el6 compat-libstdc++-33-3.2.3-69.el6.i686 gcc-4.4.4-13.el6 gcc-c++-4.4.4-13.el6 glibc-2.12-1.7.el6 glibc-2.12-1.7.el6 glibc-devel-2.12-1.7.el6 glibc-devel-2.12-1.7.el6.i686 ksh libgcc-4.4.4-13.el6 libgcc-4.4.4-13.el6 libstdc++-4.4.4-13.el6 libstdc++-4.4.4-13.el6.i686 libstdc++-devel-4.4.4-13.el6 libstdc++-devel-4.4.4-13.el6.i686 libaio-0.3.107-10.el6 libaio-0.3.107-10.el6.i686 libaio-devel-0.3.107-10.el6 libaio-devel-0.3.107-10.el6.i686 make-3.81-19.el6 sysstat-9.0.4-11.el6 linux7系统 yum install -y binutils-2.23.52.0.1-12.el7.x86_64 compat-libcap1-1.10-3.el7.x86_64 compat-libstdc++-33-3.2.3-71.el7.i686 compat-libstdc++-33-3.2.3-71.el7.x86_64gcc-4.8.2-3.el7.x86_64 gcc-c++-4.8.2-3.el7.x86_64 glibc-2.17-36.el7.i686 glibc-2.17-36.el7.x86_64 glibc-devel-2.17-36.el7.i686 glibc-devel-2.17-36.el7.x86_64 kshlibaio-0.3.109-9.el7.i686 libaio-0.3.109-9.el7.x86_64 libaio-devel-0.3.109-9.el7.i686 libaio-devel-0.3.109-9.el7.x86_64 libgcc-4.8.2-3.el7.i686 libgcc-4.8.2-3.el7.x86_64 libstdc++-4.8.2-3.el7.i686 libstdc++-4.8.2-3.el7.x86_64 libstdc++-devel-4.8.2-3.el7.i686 libstdc++-devel-4.8.2-3.el7.x86_64 libXi-1.7.2-1.el7.i686 libXi-1.7.2-1.el7.x86_64 libXtst-1.2.2-1.el7.i686 libXtst-1.2.2-1.el7.x86_64 make-3.82-19.el7.x86_64 sysstat-10.1.5-1.el7.x86_64 建立用户及配置环境变量1234567groupadd dba 建立管理组groupadd oinstall 建立安装组useradd -d /home/oracle -g oinstall -G dba -m oracle 建立oracle用户passwd oracle 修改oracle用户密码mkdir -p /u01/app/oracle/product/11.2chown -R oracle:oinstall /u01/app/oraclechmod -R 755 /u01/app/oracle 1234567su - oracle 登录oracle用户vim .bash_profile export ORACLE_BASE=/u01/app/oracle export ORACLE_HOME=$ORACLE_BASE/product/11.2 export ORACLE_SID=hdata export PATH=$ORACLE_HOME/bin:$PATHsource .bash_profile 配置系统参数123456vim /etc/security/limits.conf oracle soft nproc 2047 oracle hard nproc 16384 oracle soft nofile 1024 oracle hard nofile 65536 oracle soft stack 10240 limit.conf文件格式 username|@groupname type resource limit 1) username|@groupname 设置需要被限制的用户名，组名前面加@和用户名区别，也可以yoga通配符*来做有所用户的限制 2) type soft指的是当前系统生效的设置值，不能比hard大 hard表明系统中所能设定的最大值 - 表名同时设置了soft和hard的值 3) resource 要限制的资源 core 限制内核文件的大小 date 最大数据大小 fsize 最大文件大小 memlock 最大锁定内存地址空间 nofile 打开文件的最大数目 rss 最大持久设置大小 stack 最大栈大小 cpu 以分钟为单位的最多cpu时间 nproc 进程的最大数目 as 地址空间限制 maxlogins 此用户允许登录的最大数目 1234567891011121314vim /etc/sysctl.conf fs.aio-max-nr = 1048576 fs.file-max = 6815744 kernel.shmall = 2097152 kernel.shmmax = 536870912 kernel.shmmni = 4096 kernel.sem = 250 32000 100 128 net.ipv4.ip_local_port_range = 9000 65500 net.core.rmem_default = 262144 net.core.rmem_max = 4194304 net.core.wmem_default = 262144 net.core.wmem_max = 1048576sysctl -p sysctl.conf文件参数的意义 fs.aio-max-nr 同时可以拥有的的异步IO请求数目 fs.file-max 进程可以同时打开的最大句柄数，这个参数直接限制最大并发连接数 kernel.shmall 共享内存总量，单位页，页的大小是4K 20971524k/1024/1024 = 8G kernel.shmmax 单个进程(process)能使用的共享内存段的最大尺寸(Bytes为单位)， 一般需要根据物理内存修改，尽量让整个SGA在共享内存段中 。 kernel.shmmni 设置系统范围内共享内存段的最大数量。该参数的默认值是 4096。此值也是在系统中可以启动的Oracle实例的最大数量,通常不需要更改。 kernel.sem 表示设置的信号量，四个参数分别是：SEMMSL.每个信号集中的最大信号量数目。SEMMNS.系统范围内的最大信号量总数目。SEMOPM.每个信号发生时的最大系统操作数目。SEMMNI.系统范围内的最大信号集总数目。SEMMNS=SEMMSLSEMMNI net.ipv4.ip_local_port_range 可使用的IPv4端口范围 net.core.rmem_default 接收套接字缓冲区大小的默认值(以字节为单位)。 net.core.rmem_max 接收套接字缓冲区大小的最大值(以字节为单位)。 net.core.wmem_default 发送套接字缓冲区大小的默认值(以字节为单位)。 net.core.wmem_max 发送套接字缓冲区大小的最大值(以字节为单位)。 安装oracle程序12345678用xshell连接需要设置DISPLAY参数在root用户下执行 export DISPLAY=客户端ip:0.0正常流程需要在root下执行xhost +su - oracle 切换到oracle用户cd /tmp/database 切换到解压的目录./runInstaller 命令建库在oracle用户下输入dbca 这个地方点击下一步会弹出提示，需要先运行监听程序 在Oracle用户下输入lsnrctl status检查监听器的状态 如果如上图所示，则还未运行监听，输入lsnrctl start启动监听回到dbca建库界面就可以通过刚才那一步了 验证在oracle用户下输入ps -ef | grep ora_ 登录sqlplussqlplus / as sysdba输入select status from v$instance;查询实例状态 输入select open_mode from v$database;查看打开模式]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java封装]]></title>
    <url>%2Fhexo%2F2019%2F01%2F04%2Fjava%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[不使用封装，很容易赋值错误，并且任何人都可以更改，造成信息的不安全 封装的实现设置类的属性为privatepublic成员修饰符，公共的，谁都可以访问 private成员修饰符，私有的，只有自己可以访问 使用set、get方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Employee&#123; private String name; private String id; private String gender; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public String getId()&#123; return id; &#125; public void setId(String id)&#123; this.id = id; &#125; public String gender()&#123; return gender; &#125; public void setGender(String gender)&#123; if("男".equal(gender)||"女".equal(gender))&#123; this.gender = gender; &#125;else&#123; System.out.println("请输入\"男\"或者\"女\""); &#125; &#125; public void work()&#123; &#125;&#125;---------------------------------------------------------------public class demo&#123; public static void mian(String[] args)&#123; Employee e = new Employee(); e.setId("007"); e.setName("jame"); e.setGender("男"); System.out.println(e.getId()); System.out.println(e.getName()); System.out.println(e.getGender()); e.work(); &#125;&#125; 封装的好处 隐藏了类的具体实现 操作简单 提高对象数据的安全性]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数组]]></title>
    <url>%2Fhexo%2F2019%2F01%2F03%2Fjava%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组定义同一种类型数据的集合，其实就是一个容器。数组一旦定义，那么里边存储的数据类型也就确定了。 数组可以自动给元素编号，方便操作元素。创建数组之后不能修改数组的大小，可以使用length属性获取数组的大小。 格式元素类型[] 数组名 = new 元素类型[元素个数或数组长度];int[] arr = new int[5]; 元素类型[] 数组名 = new 元素类型[]{元素,元素,…..};int[] arr = new int[]{3,5,1,7};int[] arr = {3,5,1,7} 数组的遍历12345678public class demo&#123; public static void main(String[] args)&#123; int[] x = &#123;1,2,3&#125;; for (int i = 0 ; i &lt; x.length ; i++)&#123; System.out.println(x[i]); &#125; &#125;&#125; 数组的常见异常角标越界1234567public class demo&#123; public static void main(String[] args)&#123; int[] x = &#123;1,2,3&#125;; System.out.println(x[3]); //java.lang.ArrayIndexOutOfBoundsException:3 &#125;&#125; 空指针异常12345678public class demo&#123; public static void main(String[] args)&#123; int[] x = &#123;1,2,3&#125;; x = null; System.out.println(x[1]); //java.lang.NullPointerException &#125;&#125; 内存分析栈内存特点：存储局部变量，变量使用完，自动释放。堆内存特点：存储的是数组和对象，凡是new关键字创建的实体都保存在堆内存里面，每一个对象都有一个内存首地址，对象都有默认的初始值。 数组的方法遍历：toString()将数组的元素以字符串的形式返回排序：sort()将数组按照升序排列二分查找：binarySearch在指定数组中查找元素，返回元素的索引，如果没有找到返回-1123456789101112public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;2,45,12,3,6,23,12,53,32,15&#125; System.out.println(Arrays.toString(arr)); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); System.out.println(Arrays.binarySearch(arr,12)); &#125;&#125; 二维数组实质就是存储的一维数组 数组类型[][] 数组名 = new 数组类型[一维数组的个数][每个一维数组中的元素个数] 属猪类型[][] 数组名 = new 数组类型{元素1,元素2},{元素1,元素2,元素3},{元素1,元素2}]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序算法]]></title>
    <url>%2Fhexo%2F2019%2F01%2F03%2F%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序直接排序1234567891011121314151617181920//用当前角标上的元素和后面的所有元素进行比较public class demo&#123; public static void mian(String[] args)&#123; int[] arr = &#123;4,2,64,34,12,45&#125;; selectSort(arr); &#125; public static void selectSort(int[] arr)&#123; for(int x=0;x&lt;arr.length-1;x++)&#123; for(int y=x+1;y&lt;arr.length;y++)&#123; if(arr[x]&gt;arr[y])&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125;&#125; 冒泡排序1234567891011121314151617181920//相邻的元素进行比较public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;4,2,64,34,12,45&#125;; bubbleSort(arr); &#125; public static void bubbleSort(int[] arr)&#123; for(int x=0;x&lt;arr.length-1;x++)&#123; for(int y=0;y&lt;arr.length-x-1;y++)&#123; if(arr[y]&gt;arr[y+1])&#123; int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125;&#125; 二分法查找1234567891011121314151617181920212223//只对有序的数组有效public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;2,4,7,8,9,14,16,22,26&#125;; int a = halfSearch(arr,22); System.out.println(a); &#125; public static int halfSearch(int[] arr,int key)&#123; int min = 0; int max = arr.length-1; int mid = (min+max)/2; while(arr[mid]!=key)&#123; if(key&gt;arr[mid])&#123; min = mid + 1; &#125;else if (key&lt;arr[mid])&#123; max = mid -1; &#125; mid = (max+min)/2; &#125; return mid; &#125;&#125; 数组翻转12345678910111213141516171819public class demo&#123; public static void main(String[] args)&#123; int[] arr = &#123;4,2,64,34,12,45&#125;; reverseArray(arr); &#125; public static void reverseArray(int[] arr)&#123; for (int start=0,end=arr.length-1;start&lt;end;start++,end--)&#123; swap(arr,start,end); &#125; System.out.println(Arrays.toString(arr)) &#125; public static void swap(int arr[],int a,int b)&#123; int temp = arr[a]; arr[a]=arr[b]; arr[b]=temp; &#125;&#125; 递归函数的自身调用函数的自身前提：必须要有条件的情况下调用 123456789101112131415161718192021222324//算出5的阶层 5！=5*4*3*2*1public class demo&#123; public static void main(String[] args)&#123; int result = print(5); System.out.println("结果:"+result); &#125; public static int print(int num)&#123; if(num==1)&#123; return 1; &#125; else&#123; return num*print(num-1); &#125; &#125; public static int test(int num)&#123; int result = 1; while(num&gt;0)&#123; result = result*num; num--; &#125; return result; &#125;&#125; 装饰者设计模式增强一个类的功能，而且还可以让这些装饰类互相装饰 ——| Reader———-| BufferedReader—————-| BufferedLineNum 带行号—————-| BufferedSemi 带分号—————-| BufferedQuto 带双引 增强一个类的功能的时候我们可以选择使用继承,通过继承实现增强一个类的功能的优点：代码结构清晰，同时易懂 缺点：使用不灵活，会导致继承的体系过于庞大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class BufferedLineNum extends BufferedReader&#123; //行号 int count = 1; public BufferedLineNum(Reader in)&#123; super(in); &#125; @Override public String readLine() throws IOException&#123; String line = super.readLine(); if(line == null)&#123; return null; &#125; line = count + " " + line; count++; return line; &#125;&#125;---------------------------------------------------//带分号的缓冲输入字符流class BufferedSemi extends BufferedReader&#123; public BufferedSemi(Reader in)&#123; super(in); &#125; @Override public String readLine() throws IOException&#123; String line = super.readLine(); if(line==null)&#123; return null; &#125; line = line + ";"; return line; &#125;&#125;----------------------------------------------------class BuffereQuto extends BufferedReader&#123; public BufferedQuto(Reader in)&#123; super(in); &#125; @Override public String readLine() throws IOException &#123; String line = super.readLine(); if(line == null)&#123; return null; &#125; line = "\"" + line + "\""; return line; &#125;&#125;--------------------------------------------------public class demo&#123; public static void main(String[] args) throws IOException&#123; File file = new File("e:\\a.txt"); //建立数据的输入通道 FileReader fileReader = new FileReader(file); //建立带行号的缓冲输入字符流 BufferedLineNum bufferedLineNum = new BufferedLineNum(fileReader); //带有分号的缓冲输入字符流 BufferedSemi bufferedSemi = new BufferedSemi(fileReader); //带有双引号的缓冲输入字符流 BufferedQuto bufferedQuto = new BufferedQuto(fileReader); String line = null; while((line = buffereQuto.readline())!=null)&#123; System.out.println(line); &#125; &#125;&#125; 步骤 在装饰类的内部维护一个被装饰类的引用 让装饰类有一个共同的父类或者是父类接口 继承实现的增强类和修饰模式实现的增强类有何区别 继承实现的增强类 优点：代码结构清晰，而且实现简单 缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大 修饰装饰实现的增强类 优点：内部可以通过多态技术对多个需要增强的类进行增强，可以使这些装饰类达到互相装饰的效果，比较灵活 缺点：需要内部通过多态技术维护需要增强的类的实例，进而使用代码稍微复杂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//带行号的缓冲输入字符流class BufferedLineNum2 extends BufferedReader&#123; //内部维护一个被装饰类的引用 BufferedReader bufferedReader; int count = 1; public BufferedLineNum2(BufferedReader bufferedReader)&#123; //该语句没有任何作用，只不过是为了不让代码报错 super(bufferedReader); this.bufferedReader = bufferedReader; &#125; @Override public String readLine() throws IOException&#123; String line = bufferedReader.readLine(); if(line==null)&#123; return null; &#125; line = count + " " + line; count++; return line; &#125;&#125;---------------------------------------------------//带分号缓冲输入字符流//为什么要继承？是为了让这些装饰类的对象可以作为参数进行传递，达到互相装饰的效果class BufferedSemi2 extends BuffereReader&#123; //在内部维护一个被装饰类的引用 BufferedReader bufferedReader; public BufferedSemi2(BufferedReader bufferedReader)&#123; super(bufferedReader); this.bufferedReader = bufferedReader; &#125; @Override public String readline() throws IOException &#123; String line = bufferedReader.readLine(); if(line == null)&#123; return null; &#125; line = line + ";"; return line; &#125;&#125;--------------------------------------------------//缓冲类带双引号class BufferedQuto2 extends BufferedReader&#123; BufferedReader buffereReader; public BufferedQuto2(BufferedReader bufferedReader)&#123; super(bufferedReader); this.bufferedReader = bufferedReader; &#125; @Override public String readline() throw IOException&#123; String line = bufferedReader.readline(); if(line == null)&#123; return null; &#125; line = "\"" + line + "\""; return line; &#125;&#125;----------------------------------------------------public class demo&#123; public static void main(String[] args) throws IOException&#123; File file = new File("e:\\a.txt"); FileReader fileReader = new FileReader(file); //建立缓冲输入字符流 BufferedReader bufferedReader = new BufferedReader(fileReader); //建立带行号的缓冲输入字符流 BufferedLineNum2 bufferedLineNum2 = new BufferedLineNum2(bufferedReader); //建立带分号的缓冲输入字符流 BufferedSemi2 bufferedSemi2 = new BufferedSemo2(bufferedReader); //建立带双引号的缓冲输入字符流 BufferedQuto2 bufferedQuto2 = new BufferedQuto2(bufferedReader); String line = null; while ((line = bufferedLineNum2.readling())!=null)&#123; System.out.println(line); &#125; &#125;&#125; 一家三口每个人都会工作，儿子的工作就是画画，母亲的工作就是在儿子的基础上做一个增强，不单只可以画画，还可以上涂料，爸爸的工作就是在妈妈基础上做了增强，就是上画框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Work()&#123; public void work();&#125;----------------------------------------------------class Son implements Work&#123; @Override public void work()&#123; System.out.println("画画。。。"); &#125;&#125;---------------------------------------------------class Mother implements Work&#123; //需要被增强的类 Work worker; public Mother(Work worker)&#123; this.worker = worker; &#125; @Override public void work()&#123; worker.work(); System.out.println("给画上颜色..."); &#125;&#125;---------------------------------------------------class Father implements Work&#123; Work worker; public Father(Work worker)&#123; this.worker = worker; &#125; @Override public void work()&#123; worker.work(); System.out.println("上画框..."); &#125;&#125;-------------------------------------------------------public class demo&#123; public static void main(String[] args)&#123; Son s = new Son(); s.work(); Mother m = new Mother(s); m.work(); Father f = new Father(m); f.work(); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java函数]]></title>
    <url>%2Fhexo%2F2019%2F01%2F03%2Fjava%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数提高代码的复用性12345678910//两数相加public class demo&#123; public static void main(String[] args)&#123; System.out.println(add(4,5)); &#125; public static int add(int i,int i1)&#123; return i+i1; &#125;&#125; 函数的格式修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数2,…){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行语句;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 返回值;} 函数的特点 定义函数可以将功能代码进行封装 函数只有被调用才会被执行 函数的出现提高了代码的复用性 对于函数没有具体返回值的情况，返回值类型用关键字void表示，那么该函数中的return语句如果在最后一行可以省略不写 函数中只能调用函数，不可以在函数内部定义函数。函数之间是平级的，相互是调用的关系 123456789101112131415161718192021//学生考试成绩划分public class demo&#123; public static void main(String[] args)&#123; printGrade(90); printGrade(59.5); &#125; public static void printGrade(double score)&#123; if (score &gt;= 90.0)&#123; System.out.println("A"); &#125;else if (score &gt;= 80.0)&#123; System.out.println("B"); &#125;else if (score &gt;= 70.0)&#123; System.out.println("C"); &#125;else if (score &gt;= 60.0)&#123; System.out.println("D"); &#125;else &#123; System.out.println("F"); &#125; &#125;&#125; 函数的重载在同一个类中，有一个以上的同名函数，只要函数的参数列表或参数类型不一样即可，与返回值无关，这些统称为方法的重载 12345678910111213141516171819202122232425//乘法表public class demo&#123; public static void main(String[] args)&#123; print99(); print99(4); &#125; private static void print99()&#123; for (int i = 1 ; i &lt;= 9 ; j++)&#123; for (int j = 1; j &lt; i; j++)&#123; System.out.println(j+"*"+i+"="+(i*j)+"\t"); System.out.println(); &#125; &#125; &#125; private static void print99(int num)&#123; for (int i = 1 ; i &lt;= num ; i++)&#123; for (int j = 1 ; i &lt;= i ; j++)&#123; System.out.print(j+"*"+i+"="+(i*j)+"\t"); &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java流程控制]]></title>
    <url>%2Fhexo%2F2018%2F12%2F28%2Fjava%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[条件判断ifif(判断条件){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行的代码块1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行的代码块2;}1234567891011121314//提示用户输入一个整数，如果该整数是5的倍数，就打印"5的倍数"，如果是2的倍数就打印"2的倍数"public class demo&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); Syetem.out.println("请输入一个整数："); int nextInt = scanner.nextInt(); if(nextInt%5==0)&#123; System.out.println("5的倍数"); &#125; if(nextInt%2==0)&#123; System.out.println("2的倍数"); &#125; &#125;&#125; if…elseif(判断条件){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行代码块1}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行代码块2}1234567891011//判断一个整数是奇数还是偶数public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入一个整数："); int nextInt = scanner.nextInt(); if(nextInt%2==0)&#123; System.out.println(nextInt+"是一个偶数"); &#125;else&#123; System.out.println(nextInt+"是一个奇数") &#125;&#125; if…else if…elseif(判断条件1){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行代码块1}else if(判断条件2){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行代码块2}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行代码块3}12345678910111213141516171819202122232425//根据用户定义的数值不同，打印对应的星期public class demo &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入一个整数："); int nextInt = scanner.nextInt(); if (nextInt == 0)&#123; System.out.println("星期天"); &#125;else if (nextInt == 1)&#123; System.out.println("星期一"); &#125;else if (nextInt == 2)&#123; System.out.println("星期二"); &#125;else if (nextInt == 3)&#123; System.out.println("星期三"); &#125;else if (nextInt == 4)&#123; System.out.println("星期四"); &#125;else if (nextInt == 5)&#123; System.out.println("星期五"); &#125;else if (nextInt == 6)&#123; System.out.println("星期六"); &#125;else &#123; System.out.println("输入有误"); &#125; &#125;&#125; 选择判断switch…case…defaultswitch(表达式){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 取值1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行语句;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 取值2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行语句;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行语句;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;} switch语句的特点： 选择的类型只有四种：byte，short，int，char 先判断所有的case，没有匹配的case就执行default case后跟的值必须是常量，不能是变量 123456789101112131415161718192021222324252627282930313233public class demo &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入一个整数"); int nextInt = scanner.nextInt(); switch (nextInt)&#123; case 0: System.out.println("星期天"); break; case 1: System.out.println("星期一"); break; case 2: System.out.println("星期二"); break; case 3: System.out.println("星期三"); break; case 4: System.out.println("星期四"); break; case 5: System.out.println("星期五"); break; case 6: System.out.println("星期六"); break; default: System.out.println("输入有误"); break; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031public class filet1 &#123; public static void main(String[] args) throws Exception&#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入一个月份："); int nextInt = scanner.nextInt(); switch (nextInt)&#123; case 12: case 1: case 2: System.out.println("Winter"); break; case 3: case 4: case 5: System.out.println("Spring"); break; case 6: case 7: case 8: System.out.println("Summer"); break; case 9: case 10: case 11: System.out.println("Autumn"); break; default: System.out.println("你的输入有误"); &#125; &#125;&#125; 循环whilewhile(条件表达式){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行语句;} 12345678910//计算1到9相加的和public class demo&#123; int sum = 0; int i = 1; while(i&lt;10)&#123; sum = sum + i; i++; &#125; System.out.println(sum);&#125; 123456789101112131415161718//猜数字游戏public class demo&#123; public static void main(String[] args)&#123; int num = (int)(Math.random()*100)+1; Scanner scanner = new Scanner(System.in); while(true)&#123; System.out.println("请输入1-100之间的整数"); int guessNum = Scanner.nextInt(); if(guessNum == num)&#123; System.out.println("中了"); &#125;else if(guessNum &lt; num)&#123; System.out.println("小了"); &#125;else&#123; System.out.println("大了") &#125; &#125; &#125;&#125; do…whiledo{&nbsp;&nbsp;&nbsp;&nbsp;执行语句;}while(条件表达式)无论条件是否满足，循环体至少被执行一次 12345678910111213141516171819202122//猜数字public class demo &#123; public static void main(String[] args) &#123; int guess = -1; int count = 0; int num = (int)(Math.random()*100)+1; Scanner scanner = new Scanner(System.in); do&#123; System.out.println("请输入1-100之间的数字"); guess = scanner.nextInt(); if (guess &gt; num)&#123; System.out.println("大了"); &#125;else if (guess &lt; num)&#123; System.out.println("小了"); &#125;else &#123; System.out.println("猜中了"); &#125; count++; &#125;while (num!=guess); System.out.println("你猜测的数字是："+num+"猜测了"+count+"次"); &#125;&#125; Math.random() 生成0-1之间的数字，double型Math.random()10 生成0-10之间的数字，double型(int)(Math.random()10) 强转int类型，去掉小数点，取0-9，便于计算(int)(Math.random()*10)+1 生成1-10之间的随机数 forfor(初始表达式;循环表达式;操作表达式){ &nbsp;&nbsp;&nbsp;&nbsp;执行语句;}12345678//想要打印5次helloworldpublic class dome&#123; public static void main(String[] args)&#123; for(int x=0;x&lt;5;x++)&#123; System.out.println("hello world"); &#125; &#125;&#125; 导致无限循环的格式while(true)和for（;;） 123456789101112//语句的嵌套//99乘法表public class demo&#123; public static void main(String[] arg)&#123; for (int x = 1 ; x &lt;= 9 ; x++)&#123; for ( int y = 1 ; y &lt;= x ; y++)&#123; System.out.print(y+"*"+x+"="+(x*y)+"\t"); &#125; System.out.println(); &#125; &#125;&#125; break和continuebreak终止最近的封闭循环，不会执行后面的语句，可以单独使用，也可以与标签一起使用 123456789101112131415public class demo&#123; public static void main(String[] args)&#123; for (int i = 0 ; i &lt; 4 ; i++)&#123; break; System.out.println("Hello world"); //这句话不会被执行 &#125; outer:for (int i = 0 ; i &lt; 5 ; i ++)&#123; inner: for(int j = i ; j &lt; 5 ; j ++)&#123; System.out.println("*"); break outer; //终止outer标签部分的for循环 &#125; System.out.println("\r\n"); &#125; &#125;&#125; continue跳出本次循环，执行下一次12345678910public class demo&#123; public static void main(String[] args)&#123; for (int i=0 ; i&lt; 10 ; i++)&#123; if (i == 5)&#123; continue; //跳过i=5 &#125; System.out.println(i); &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java运算符]]></title>
    <url>%2Fhexo%2F2018%2F12%2F28%2Fjava%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[算数运算符1234567+ 加- 减* 乘/ 除% 取余++ 自增-- 自减 赋值运算符123456= 等于+= 加等于-= 减等于*= 乘等于/= 除等于%= 模等于 比较运算符1234567&gt; 大于&lt; 小于&gt;= 大于等于&lt;= 小于等于== 相等!= 不相等instanceof 检查是否是类的对象 逻辑运算符1234&amp;&amp; 与|| 或! 非^ 异或 位运算符1234&amp; and 两边都为1，结果为1，否则为0| or 两边都为0，结果为0，否则为1^ xor 两边不同，结果为1，否则为0~ 取反 异或特点一个数异或同一个数两次，结果还是那个数例 6^3^3=6 可以用于两个值进行交换 负数的二进制表示负数的二进制就是对应的正数的二进制取反之后加1例如 -6|00000000|00000000|00000000|00000110|6||—–|—–|—-|—-|–||11111111|11111111|11111111|11111001|取反||11111111|11111111|11111111|11111010|-6| 条件运算符12布尔表达式?表达式1:表达式2 布尔表达式为true，则返回表达式1，否则返回表达式2 移位操作符123&lt;&lt; 左移 空位补0，被移除的高位丢弃，空缺位补0&gt;&gt; 右移 被移动的二进制最高位是0，右移后，空缺位补0，最高位是1，空缺位补1&gt;&gt;&gt; 无符号右移 被移动二进制最高位无论是0或者是1，空缺位都用0补]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本数据类型]]></title>
    <url>%2Fhexo%2F2018%2F12%2F28%2Fjava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[java的基本数据类型有八种 字符型 char使用’’引起来的单个字符,例如&#39;a&#39; boolean类型true 真false 假默认值是false 整数类型 类型 占位 范围 byte(字节) 8bit -128~127 short(短整型) 16bit -32768~32767 int(整型) 32bit -$2^{31}$~$2^{31}$-1 long(长整型) 64bit -$2^{63}$~$2^{63}$-1 整型默认为int类型 小数类型 （符合IEEE754）float 单精度 32bit 需要在数字结尾加上f，例如 12.3f，默认值为0.0fdouble 双精度 64bit 默认值为0.0d浮点数默认为double类型，浮点数不能用来表示精确的值，如货币 数据类型的转换自动类型转换（隐式转换）满足两个条件，彼此兼容并且目标类型取值范围大于源类型例：byte b = 100;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = b程序把b结果自动转换成int类型 强制类型转换(显示转换)将一个数值赋值给范围更小的数值范围的变量例： byte b = 100;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = b + 2;2默认为int类型，b+2的时候b变量存储的值自动类型提升为int，运算结果为int类型，把int的值放入到byte的变量b中，无法放入，编译报错。可以写成 b = (byte)(b+2)或者 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b += 2 强制转换可能会损失精度]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识]]></title>
    <url>%2Fhexo%2F2018%2F12%2F28%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[java的环境 jre: java运行环境jre = java虚拟机（JVM）+ 核心类库（辅助java虚拟机运行的文件） jdk：java开发工具集jdk = jre + java开发工具 jdk目录 bin：存放java的开发工具db：JDK附带的一个轻量级的数据库，叫做Derbyjre：java运行环境lib：核心类库src.zip：java源代码 环境变量 classpath：java类文件的目录path：程序文件bin目录JAVA_HOME：java主目录 注释的种类 单行注释：//注释多行注释：/&lowast; 注释 &lowast;/文档注释：/&lowast;&lowast; 注释 &lowast;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@author 作者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@version 版本&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@param 方法的参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@return 返回值 转义符 转义字符 名称 \b Backspace(退格键) \t Tab \n 换行 \r 回车 \\ 反斜杠 \‘ 单引号 \“ 双引号 常量和变量常量是指在程序运行过程中，值是固定不变的变量指的是存储一段内存地址，可以修改存储地址]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos6安装mysql5.6]]></title>
    <url>%2Fhexo%2F2018%2F12%2F28%2F%E5%AE%89%E8%A3%85mysql5-6%2F</url>
    <content type="text"><![CDATA[关闭防火墙手动关闭当前系统中的防火墙service iptables stop 检查防火墙是否关闭service iptables status 关闭启动项的防火墙chkconfig iptables off 检查启动项的防火墙是否关闭chkconfig --list 注意：需要检查selinux修改/etc/selinux/config，将selinux的值改成disable 配置sysctl.conf1234567891011vm.swappiness = 0net.ipv4.neigh.default.gc_stale_time=120net.ipv4.conf.all.rp_filter=0net.ipv4.conf.default.rp_filter=0net.ipv4.conf.default.arp_announce = 2net.ipv4.conf.all.arp_announce=2net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.ipv4.conf.lo.arp_announce=2 检查是否已安装有mysqlrpm -qa | grep mysql如果已经安装了mysql，可以通过rpm -e mysql或者rpm -e --nodeps mysql或者yum remove mysql来删除mysql包 下载mysql源码包并上传到服务器https://dev.mysql.com/downloads/mysql/ 添加用户和组添加mysql组groupadd mysql添加用户组useradd -d /home/mysql -g mysql -m mysql设置密码passwd mysql 配置mysql环境变量登录mysql用户su - mysql配置用户环境变量 vim .bash_profile在PATH变量后面添加mysql的bin目录PATH=$PATH:/u01/mysql/bin立即生效环境变量 source .bash_profile 创建目录及授权(root用户下)创建数据目录mkdir -p /u01/mysql/data创建日志目录mkdir -p /u01/mysql/log/iblogmkdir -p /u01/mysql/log/binlog创建socket pid目录mkdir -p /u01/mysql/run创建临时目录mkdir -p /u01/mysql/tmp授权chown -R mysql:mysql /u01/mysqlchmod -R 755 /u01/mysql 解压mysql5.6tar -zxvf mysql-5.6.37.tar.gz 安装包及cmakeyum install -y cmake gcc gcc-c++ ncurses-devel bison zlib libxml openssl openssl-devel ncurses cmake编译在解压的源码包下面执行12345678910111213141516171819cmake \ -DCMAKE_INSTALL_PREFIX=/u01/mysql \ #基本目录 -DINSTALL_DATADIR=/u01/mysql/data \ #数据目录 -DDEFAULT_CHARSET=utf8 \ #字符集 -DDEFAULT_COLLATION=utf8_general_ci \ # 字符集排序 -DEXTRA_CHARSETS=all \ #支持哪些额外的字符集 -DWITH_SSL=yes \ #安全套接字 -DWITH_EMBEDDED_SERVER=1 \ #编译嵌入式服务器支持 -DENABLED_LOCAL_INFILE=1 \ #是否启用本地数据导入支持 -DWITH_MYISAM_STORAGE_ENGINE=1 \ #是否安装myisam -DWITH_INNOBASE_STORAGE_ENGINE=1 \ #是否安装innobase -DWITH_ARCHIVE_STORAGE_ENGINE=1 \ #是否安装archive -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ # 是否安装blackhole -DWITH_FEDERATED_STORAGE_ENGINE=1 \ # 是否安装federated -DWITH_PARTITION_STORAGE_ENGINE=1 \ # 是否安装partition -DMYSQL_UNIX_ADDR=/u01/mysql/run/mysql.sock \ # mysql进程间通讯的套接字的位置 -DMYSQL_TCP_PORT=3306 \ # 默认端口 -DSYSCONFDIR=/etc \ # 配置参数地址 -DWITH_READLINE=on # 启用readline库支持 编译 make &amp;&amp; make install 编译的参数可以参考http://dev.mysql.com/doc/refman/5.5/en/source-configuration-options.html 配置mysql参数拷贝mysql.cnf到/u01/mysql设置文件的权限 初始化脚本(mysql用户下)到/u01/mysql/scripts下执行1./mysql_install_db --defaults-file=/u01/mysql/my.cnf --basedir=/u01/mysql --datadir=/u01/mysql/data --user=mysql 启动mysql（bin目录下）1./mysqld_safe --defaults-file=/u01/mysql/my.cnf --user=mysql &amp; 设置开机启动123cp support-files/mysql.server /etc/init.d/mysqlchkconfig mysql onservice mysql start --启动MySQL 多端口实例的情况下需要用下面的命令登录1mysql -uroot -p --socket=/u01/mysql/run/mysql.sock --port=3307 修改root密码12mysql -urootmysql&gt; SET PASSWORD = PASSWORD('123456'); 停止mysql1./mysqladmin -uroot -poracle -S /u01/my3306/run/mysql.sock shutdown &amp;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime常用按键]]></title>
    <url>%2Fhexo%2F2018%2F12%2F27%2Fsublime%E5%B8%B8%E7%94%A8%E6%8C%89%E9%94%AE%2F</url>
    <content type="text"><![CDATA[最常用的 1、新建文件-输入”html:xt”后 按”Ctrl+E键”或 “tab键” ,可快速生成xhtml 1.0的模板2、新建文件-输入”html:5”后 按”Ctrl+E键”或 “tab键” ,可快速生成HTML5的模板3、新建文件-输入”!”后 按”Ctrl+E键”或 “tab键” ,可快速生成HTML5的模板 Ctrl+Shift+ [ 折叠代码 (在CSS中表示紧凑格式，在html中为折叠代码)Ctrl+Shift+ ] 折叠代码 (在CSS中表示扩张格式，在html中为恢复折叠代码) Ctrl+Shift+C CSS属性排序Ctrl+Alt+N 快速创建文件(填上文件扩展名可生成模板，例如：demo.html)Ctrl+Alt+K 刪除不必要的空白Ctrl+Shift+Alt+F 格式化JS代码Ctrl+Shift+Alt+M 压缩CSS/JS代码(生成结果为：文件名.min.css、文件名.min.js) F1 Chrome浏览器预览F2 Firefox浏览器预览F3 IE浏览器预览F4 打开调色盘F11 全屏F12 默认浏览器预览 ##按住鼠标滚轮下拉可多行编辑 Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）Ctrl+G 跳转到相应的行Ctrl+J 合并行（已选择需要合并的多行时）Ctrl+L 选择整行（按住-继续选择下行）Ctrl+M 光标移动至括号内开始或结束的位置Ctrl+T 词互换Ctrl+U 软撤销Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题/函数；或者输入 : 跳转到文件某行；Ctrl+R 快速列出/跳转到某个函数Ctrl+K Backspace 从光标处删除至行首Ctrl+K+B 开启/关闭侧边栏Ctrl+KK 从光标处删除至行尾Ctrl+K+T 折叠属性Ctrl+K+U 改为大写Ctrl+K+L 改为小写Ctrl+K+0 展开所有Ctrl+Enter 插入行后（快速换行）Ctrl+Tab 当前窗口中的标签页切换 Ctrl+Shift+A 选择光标位置父标签对儿Ctrl+Shift+D 复制光标所在整行，插入在该行之前ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找Ctrl+Shift+K 删除整行Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）Ctrl+Shift+P 打开命令面板Ctrl+Shift+/ 注释已选择内容Ctrl+Shift+↑可以移动此行代码，与上行互换Ctrl+Shift+↓可以移动此行代码，与下行互换Ctrl+Shift+[ 折叠代码Ctrl+Shift+] 展开代码Ctrl+Shift+Enter 光标前插入行 Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换 Ctrl+Z 撤销Ctrl+Y 恢复撤销Ctrl+F2 设置/取消书签Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果）Ctrl+鼠标左键 可以同时选择要编辑的多处文本 Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择Shift+F2 上一个书签Shift+Tab 去除缩进Alt+Shift+1（非小键盘）窗口分屏，恢复默认1屏Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏 Ctrl+Shift+分屏序号 将当前焦点页分配到分屏序号页 Alt+. 闭合当前标签Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑 Tab 缩进 自动完成F2 下一个书签F6 检测语法错误F9 行排序(按a-z)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>文档编辑工具</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5]]></title>
    <url>%2Fhexo%2F2018%2F12%2F27%2FHTML5%2F</url>
    <content type="text"><![CDATA[浏览器内核 Trident(IE内核)、EgdeHTML内核 Gecko(firefox) webkit(Safari) Chromuim/Blink(chrome) Presto(Opera) Web标准 结构(Structure) 表现(Presentation) 行为(Behavior) HTML骨架格式1234567&lt;HTML&gt; &lt;!-- 根节点 --&gt; &lt;head&gt; &lt;!-- 头标签 --&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 标题 --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 主体标签 --&gt; &lt;/body&gt;&lt;/HTML&gt; 标签分类 双标签 &lt;标签名&gt;内容&lt;/标签名&gt; 单标签 &lt;标签名/&gt; 文档类型1&lt;!DOCTYPE html&gt; &lt;!-- html第一行添加，表明使用的是HTML5版本 --&gt; 字符集1&lt;meta charset="UTF-8"&gt; &lt;!-- 指定字符集 --&gt; HTML标签排版标签12345678910111213141516171819202122标题标签，从大到小&lt;h1&gt;标题文本&lt;/h1&gt;&lt;h2&gt;标题文本&lt;/h2&gt;&lt;h3&gt;标题文本&lt;/h3&gt;&lt;h4&gt;标题文本&lt;/h4&gt;&lt;h5&gt;标题文本&lt;/h5&gt;&lt;h6&gt;标题文本&lt;/h6&gt;段落标签&lt;p&gt;文本内容&lt;/p&gt;水平线标签(单标签)&lt;hr /&gt;换行标签&lt;br /&gt;div标签&lt;div&gt; 这是头部 &lt;/div&gt;span标签&lt;span&gt; 今日价格 &lt;span&gt; 文本格式化标签123456789101112131415粗体&lt;strong&gt; 粗体1 &lt;/strong&gt; &lt;!-- XHTML推荐 --&gt;&lt;b&gt; 粗体2 &lt;/b&gt;斜体&lt;em&gt; 斜体1 &lt;/em&gt; &lt;!-- XHTML推荐 --&gt;&lt;i&gt; 斜体2 &lt;/i&gt;加删除线&lt;del&gt; 带删除线1 &lt;/del&gt; &lt;!-- XHTML推荐 --&gt;&lt;s&gt; 带删除线2 &lt;/s&gt;加下划线&lt;ins&gt; 带下划线 &lt;/ins&gt; &lt;u&gt; 带下划线 &lt;/u&gt; 标签属性1&lt;标签名 属性1="属性值1" 属性2="属性值2" ...&gt; 内容 &lt;/标签名&gt; 图像标签1&lt;img src="图像URL" /&gt; img 标记属性 src 图像的路劲 alt 图像不能显示的时候，显示的文本 title 鼠标悬停时显示的文字 width 设置图像的宽度(像素、百分比) height 设置图像的高度(像素、百分比) border 设置图像的边框 链接标签1&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt; href用于指定链接目标的url地址 外部链接写法 https://www.xxx.com 内部链接写法 xxx.html 空链接写法 # 锚点定位写法 #id名 (跳到目标位置) target 用于指定链接页面的打开方式 _self 在当前窗口打开(默认) _blank 在新窗口打开 base标签可以设置整体链接的打开状态，写到head标签内1234&lt;head&gt; &lt;title&gt;base的用法&lt;/title&gt; &lt;base target="_blank" /&gt; &lt;!--页面的所有链接都在新窗口打开--&gt;&lt;/head&gt; 特殊字符标签 html字符 显示结果 描述 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;amp; &amp; and符号 &amp;quot; &quot; 引号 &amp;reg; &reg; 注册符号 &amp;copy; &copy; 版权符号 &amp;trade; &trade; 商标符号 &amp;nbsp; &nbsp; 空格 注释标签1&lt;!-- 注释语句 --&gt; 列表标签无序标签ul12345&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt;&lt;/ul&gt; 列表项1 列表项2 列表项3 有序标签12345&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt;&lt;/ol&gt; 列表项1 列表项2 列表项3 自定义列表12345678&lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt;&lt;/dl&gt; 标题1 内容1 内容2 标题2 内容1 内容2 表格标签1234567891011&lt;table&gt; &lt;!-- 定义一个表格 --&gt; &lt;caption&gt;标题&lt;/caption&gt; &lt;tr&gt; &lt;!-- 用于定义表格中的行 --&gt; &lt;th&gt;表头标签&lt;/th&gt; &lt;!-- 表头，非必须项 --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; &lt;!-- 用于定义表格中的单元格 --&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 表格属性 border设置表格的边框，默认为0，单位为像素 cellspacing 设置单元格边框之间的间距，默认为2px cellpadding 设置单元格内容与单元格边框之间的间距，默认为1px width 表格的宽度 height 表格的高度 align 表格在网页中的水平对齐方式，常用值为left/center/right 表格结构12&lt;thead&gt;&lt;/thead&gt; 用于定义表格头部，必须在&lt;table&gt;&lt;/table&gt;内，一般包含网页的logo和导航等头部信息&lt;tbody&gt;&lt;/tbody&gt; 用于定义表格的主体，在&lt;table&gt;&lt;/table&gt;内，一般包含网页中除头部和底部之外的其他内容 123456789101112131415161718192021222324&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;第一列&lt;/th&gt; &lt;th&gt;第二列&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;脚1&lt;/td&gt; &lt;td&gt;脚2&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 合并单元格 跨行合并：rowspan=”合并几行” 跨列合并：colspan=”合并几列” 表单标签 完整的表单通常由表单控件(表单元素)、提示信息和表单域三个部分构成 表单控件：如文本输入框、密码输入框、复选框、提交按钮、重置按钮 提示信息：提示用户进行填写和操作 表单域：相当于一个容器，用来容纳表单控件和提示信息 input控件12345678910111213141516171819202122232425262728293031&lt;input /&gt;1 type="text" 单行文本输入框2 type="password" 密码输入框3 type="radio" 单选按钮，通过name来分组4 type="checkbox" 复选框5 type="button" 普通按钮6 type="submit" 提交按钮7 type="reset" 重置按钮8 type="image" 图像形式的提交按钮9 type="file" 文件域,上传文件10 type="email" 邮箱框11 type="tel" 手机框12 type="number" 数字框13 type="url" 网址框14 type="search" 搜索框15 type="range" 滑块框16 type="time" 小时分钟17 type="date" 年月日18 type="mouth" 年月19 type="color" 调色板20 name="xxx" 控件的名称21 value="xxx" input控件中的默认文本值22 size=xxx input控件在页面中的显示宽度23 checked="checked" 定义选择控件默认被选中的项24 maxlength=xxx 控件允许输入的最多字符数25 placeholder="xxxx" 占位符，当用户输入的时候里面的文字消失，删除所有问题之后出现26 autofocus 自动获得焦点27 multiple 多文件上传，配合file类型28 autocomplete 自动记录用于下次提示，需要提交按钮、name值29 required 不能为空30 accesskey="x" 通过快捷键定位焦点，例如 alt+x label标签label标签为input元素定义标注，用于绑定一个表单元素，当点击label标签的时候，被绑定的表单元素就会获得输入焦点 123for="id号"属性规定label与哪个表单元素绑定&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; textarea控件(文本域)12如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;&lt;textarea cols="每行中的字符数" rows="显示的行数"&gt;文本内容&lt;/textarea&gt; 下拉菜单12345&lt;select&gt; &lt;option&gt;选项1&lt;option&gt; &lt;option&gt;选项2&lt;option&gt; &lt;option&gt;选项3&lt;option&gt;&lt;/select&gt; &lt;select&gt;&lt;/select&gt;中至少包含一对&lt;option&gt;&lt;/option&gt;在option中定义selected=”selected”时，当前项为默认选中项 表单域form标签用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器123&lt;form action="url地址" method="提交方式" name="表单名称"&gt;各种表单控件&lt;/form&gt; 常用属性 action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址 method用于设置表单数据的提交方式，取值为get（地址栏显示）或者post（地址栏隐藏） name用于指定表单的名称，以区分一个页面中的多个表单 其他常用标签12345678&lt;header&gt;文档的页眉&lt;/header&gt;&lt;nav&gt;导航栏&lt;/nav&gt;&lt;footer&gt;文档的页脚&lt;/footer&gt;&lt;article&gt;定义文章&lt;/article&gt;&lt;section&gt;文章中的节和区段&lt;/section&gt;&lt;aside&gt;侧边栏&lt;/aside&gt;&lt;datalist&gt;选项列表&lt;/datalist&gt; 搭配input中的text使用，input设置list属性，在datalist中有设置id的值与list相同&lt;fieldset&gt;&lt;/fieldset&gt; 可将表单内的相关元素分组打包 legend搭配使用 123456&lt;input type="text" name="text" list="text" &gt;&lt;datalist id="text"&gt;&lt;option value="中国"&gt;&lt;/option&gt;&lt;option value="美国"&gt;&lt;/option&gt;&lt;option value="英国"&gt;&lt;/option&gt;&lt;/datalist&gt; 示例： 1234567&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;学生卡&lt;/legend&gt; 姓名:&lt;input type="text" name=""&gt;&lt;br&gt; 年龄:&lt;input type="number" name=""&gt; &lt;/fieldset&gt;&lt;/form&gt; 学生卡 姓名: 年龄: 多媒体标签 &lt;embed&gt;&lt;/embed&gt; 播放多媒体&lt;audio&gt;&lt;/audio&gt; 音频播放 &nbsp;&nbsp;&nbsp;&nbsp;src 音频路径 &nbsp;&nbsp;&nbsp;&nbsp;autoplay=”autoplay” 自动播放 &nbsp;&nbsp;&nbsp;&nbsp; controls 播放控制台 &nbsp;&nbsp;&nbsp;&nbsp; loop 循环播放 &nbsp;&nbsp;&nbsp;&nbsp; &lt;source src=”…”&gt; 多种音频格式，用于兼容各种浏览器&lt;video&gt;&lt;/video&gt; 视频播放]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java File类操作]]></title>
    <url>%2Fhexo%2F2018%2F12%2F27%2FJava-File%E7%B1%BB%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[操作方法1234567891011121314151617181920212223242526272829303132File(String pathname)File(File parent,String child)File(String parent,String child)file.exists() //文件或文件夹是否存在File.separator() //查看文件系统的目录分隔符file.createNewFile() //创建一个空文件dir.mkdir() //创建一个目录dir.mkdirs() //迭代创建多个目录dir.renameTo(File dest) //重命名文件或文件夹file.delete() //删除文件或者文件夹file.deleteOnExit() //JVM终止时删除文件或者目录file.isFile() //是否是文件dir.isDirectory() //是否是目录file.isHidden() //是否是隐藏文件或目录file.isAbsolute() //是否是绝对路径file.getName() //获取文件或文件夹的名称，不包含路径file.getPath() //获取路径file.getAbsolute() //获得绝对路径file.length() //获得文件的大小file.getParent() //获得父路径file.lastModified() //获得最后一次修改时间File.listRoot() //列出所有的根目录file.list() //返回目录下的文件或者目录名，包含隐藏文件file.listFiles() //返回目录下的文件或者目录对象，包含绝对路径file.list(FilenameFilter filter) //返回指定当前目录下符合过滤条件的子文件或者子目录file.listFiles(FilenameFilter filter) //返回指定当前目录下符合过滤条件的子文件或者子目录 操作实例12345678public class FileTest &#123; public static void main(String[] args) &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt/Filetest.txt"); File file1 = new File("E:\\Jtxt\\","JavaFile.txt"); &#125;&#125; 12345678public class FileTest &#123; public static void main(String[] args) &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt/Filetest.txt"); //查看指定文件或文件夹是否存在 System.out.println(file.exists()); &#125;&#125; 12345678public class FileTest &#123; public static void main(String[] args) &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt/Filetest.txt"); //文件系统的分隔符 System.out.println(File.separator); &#125;&#125; 12345678910111213141516public class FileTest &#123; public static void main(String[] args) throws Exception &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt/Filetest.txt"); File file1 = new File("E:/Jtxt/File"); File file2 = new File("E:/Jtxt/f1/f2/f3"); //创建文件 file.createNewFile(); //创建文件夹 file1.mkdir(); //创建多层文件夹 file2.mkdirs(); //重命名 file.renameTo(new File("E:/Jtxt/Filt1.txt")); &#125;&#125; 12345678910public class FileTest &#123; public static void main(String[] args) throws Exception &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt/Filetest.txt"); //删除文件或文件夹 file.delete(); //JVM终止时删除文件或文件夹 file.deleteOnExit(); &#125;&#125; 123456789101112131415public class FileTest &#123; public static void main(String[] args) throws Exception &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt/Filetest.txt"); File dir = new File("E:/Jtxt/File"); //是否是文件 System.out.println(file.isFile()); //是否是目录 System.out.println(dir.isDirectory()); //是否是隐藏文件或目录 System.out.println(file.isHidden()); //是否是绝对路径 System.out.println(file.isAbsolute()); &#125;&#125; 12345678910111213141516171819public class FileTest &#123; public static void main(String[] args) throws Exception &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt/Filetest.txt"); //获得文件或文件夹的名称，不包含路径 System.out.println(file.getName()); //获得路径 System.out.println(file.getPath()); //获得绝对路径 System.out.println(file.getAbsolutePath()); //获得文件的大小 System.out.println(file.length()); //获得父路径 System.out.println(file.getParent()); //获得最后一次修改时间 System.out.println(file.lastModified()); &#125;&#125; 12345678910111213141516171819202122public class FileTest &#123; public static void main(String[] args) throws Exception &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt"); //列出所有的根目录 File[] files = File.listRoots(); for (File dir : files)&#123; System.out.println(dir); &#125; //列出目录下的文件或目录名，包含隐藏文件 String[] files1 = file.list(); for (String dirname : files1)&#123; System.out.println(dirname); &#125; //累出目录下的文件或者目录对象，包含绝对路径 File[] files2 = file.listFiles(); for (File dirname : files2)&#123; System.out.println(dirname); &#125; &#125;&#125; 123456789101112131415161718192021222324public class FileTest &#123; public static void main(String[] args) throws Exception &#123; //指定一个文件或文件夹 File file = new File("E:/Jtxt"); //返回指定当前目录下符合过滤条件的子文件或子目录 String[] files = file.list(new MyFilter()); for(String dir : files)&#123; System.out.println(dir); &#125; //返回指定当前目录下符合过滤条件的子文件或者子目录 File[] files1 = file.listFiles(new MyFilter()); for(File dir : files1)&#123; System.out.println(dir); &#125; &#125;&#125;class MyFilter implements FilenameFilter&#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith("txt"); &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java IO流]]></title>
    <url>%2Fhexo%2F2018%2F12%2F27%2Fjava-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[IO流划分 数据流向划分——–|输入流——–|输出流处理的单位划分——–|字节流(二进制数据)——–|字符流(以字符为单位) 字节流 InputStream 所有输入字节流的基类——–| FileInputStream 读取文件数据的输入字节流——–| BufferedInputStream 缓冲输入字节流 OutputStream 所有输出字节流的基类——–| FileOutputStream 向文件输出数据的输出字节流——–| BufferedOutputStream 缓冲输出字节流 字节流实现步骤FileInputStream 读取文件步骤 找到目标文件 建立数据的输入通道 读取文件中的数据 关闭资源 123456789101112public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/Filetest.txt"); FileInputStream fileInputStream = new FileInputStream(file); int length=0; byte[] buf = new byte[1024]; while((length=fileInputStream.read(buf))!=-1)&#123; System.out.println(new String(buf,0,length)); &#125; fileInputStream.close(); &#125;&#125; BufferedInputStream步骤 找到目标文件 建立数据的输入通道 建立缓冲输入字节流 关闭资源 12345678910111213public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/Filetest.txt"); FileInputStream fileInputStream = new FileInputStream(file); BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); int length = 0; byte[] buff = new byte[1024*8]; while ((length=bufferedInputStream.read(buff))!=-1)&#123; System.out.println(new String(buff,0,length)); &#125; bufferedInputStream.close(); &#125;&#125; FileOutputStream步骤 找到目标文件 建立数据的输出通道 把数据转换成字节数组写出 关闭资源 123456789public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java.txt"); FileOutputStream fileOutputStream = new FileOutputStream(file); String s = "湖南省长沙市岳麓区"; fileOutputStream.write(s.getBytes("UTF8")); fileOutputStream.close(); &#125;&#125; BuffereOutputStream步骤 找到目标文件 建立数据的输出通道 把数据写出 关闭资源 12345678910public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java1.txt"); FileOutputStream fileOutputStream = new FileOutputStream(file); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream); String s = "大江东去，浪淘尽，千古风流人物。故垒西边，人道是，三国周郎赤壁。乱石穿空，惊涛拍岸，卷起千堆雪。"; bufferedOutputStream.write(s.getBytes("UTF8")); bufferedOutputStream.close(); &#125;&#125; 实现拷贝效果123456789101112131415public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java1.txt"); File file1 = new File("e:/Jtxt/java2.txt"); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file1)); int content = 0; byte[] buff = new byte[1024*8]; while ((content=bis.read(buff))!=-1)&#123; bos.write(buff,0,content); &#125; bos.close(); bis.close(); &#125;&#125; 字符流 Reader输入字符流的基类——-| FileReader 读取文件的输入字符流——-| BufferedReader 缓冲输入字符流 Writer 输出字符流的基类——-| FileWriter 写入文件的输出字符流——-| BufferedWriter 缓冲输出字符流，提供了一个8192长度的字符数组 FileReader步骤 找到目标文件 建立数据的输入通道 读取数据 关闭资源 1234567891011public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java1.txt"); FileReader fileReader = new FileReader(file); int content = 0; char[] buff = new char[1024]; while ((content=fileReader.read(buff))!=-1)&#123; System.out.println(new String(buff,0,content)); &#125; &#125;&#125; BufferedReader步骤 找到目标文件 建立数据的输入通道 1234567891011public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java1.txt"); FileReader fileReader = new FileReader(file); BufferedReader bufferedReader = new BufferedReader(fileReader); String line = null; while ((line=bufferedReader.readLine())!=null)&#123; System.out.println(line); &#125; &#125;&#125; FileWriter步骤 找到目标文件 建立数据的输出通道 写出数据 关闭资源 123456789101112131415public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java3.txt"); FileWriter fileWriter = new FileWriter(file); String s = "明月几时有？把酒问青天。\n" + "\n" + "不知天上宫阙，今夕是何年。\n" + "\n" + "我欲乘风归去，\n" + "\n" + "又恐琼楼玉宇，高处不胜寒。"; fileWriter.write(s); fileWriter.close(); &#125;&#125; BufferedWriter步骤 找到目标文件 建立数据的输出通道 12345678910111213public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java4.txt"); FileWriter fileWriter = new FileWriter(file); BufferedWriter bufferedWriter = new BufferedWriter(fileWriter); String s = "这是苏轼的一首名词《卜算子》。" + "现在通行的各个版本的词选中都有一个小序：“黄州定慧院寓居作。”" + "据史料记载，此词为公元1083年（神宗元丰六年）初作于黄州，" + "定慧院在今天的湖北黄冈县东南，苏轼另有《游定惠院记》一文。"; bufferedWriter.write(s); bufferedWriter.close(); &#125;&#125; 实现拷贝效果1234567891011121314public class FileTest &#123; public static void main(String[] args) throws Exception &#123; File file = new File("e:/Jtxt/java3.txt"); File file1 = new File("e:/Jtxt/java5.txt"); BufferedReader br = new BufferedReader(new FileReader(file)); BufferedWriter bw = new BufferedWriter(new FileWriter(file1)); String line = null; while ((line=br.readLine())!=null)&#123; bw.write(line); &#125; bw.close(); br.close(); &#125;&#125; 序列流SequenceInputStream 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//把a.txt与b.txt文件的内容合并public class demo&#123; public static void main(String[] args) throws IOException&#123; merge3(); &#125; //把三个文件合并成一个文件 public static void merge3() throws IOException&#123; //找到目标文件 File file1 = new File("e:\\a.txt"); File file2 = new File("e:\\b.txt"); File file3 = new File("e:\\c.txt"); File file4 = new File("e:\\d.txt"); //建立对应的输入输出流对象 FileOutputStream fileOutputStream = new FileOutputStream(file4); FileInputStream fileinputstream1 = new FileInputStream(file1); FileInputStream fileinputstream2 = new FileInputStream(file2); FileInputStream fileinputstream3 = new FileInputStream(file3); //创建序列流对象 Vector&lt;FileInputStream&gt; vector = new Vector&lt;FileInputStream&gt;(); vector.add(fileinputstream1); vector.add(fileinputstream2); vector.add(fileinputstream3); Enumeration&lt;FileInputStream&gt; e = vector.elements(); SequenceInputStream sequenceinputstream = new SequenceInputStream(e); //读取文件数据 byte[] buf = new byte[1024]; int length = 0; while((length = sequenceinputstream.read(buf))!=-1)&#123; fileOutputStream.write(buf,0,length); &#125; //关闭资源 sequenceinputstream.close(); fileoutputstream.close(); &#125; //使用sequenceinputstream合并文件 public static void merge2() throws IOException&#123; //找到目标文件 File infile1 = new File("e:\\a.txt"); File infile2 = new File("e:\\b.txt"); File outfile = new File("e:\\c.txt"); //建立数据的输入输出通道 FileOutputStream fileOutputStream = new FileOutputStream(outfile); FileInputStream fileInputStream = new FileOutputStream(infile1); FileInputStream fileInputStream = new FileOutputStream(infile2); //建立序列流对象 SequenceInputStream inputStream = new SequenceInputStream(fileInputStream1,fileInputStream2); byte[] buf = new byte[1024]; int length = 0; while((length = inputStream.read(buf))!=-1)&#123; fileOutputStream.write(buf,0,length); &#125; //关闭资源 inputStream.close; fileOutputStream.close; &#125; //把a.txt与b.txt文件的内容合并 public static void merge1() throws IOException&#123; //找到目标文件 File infile1 = new File("e:\\a.txt"); File infile2 = new File("e:\\b.txt"); File outfile = new File("e:\\c.txt"); //建立数据的输入输出通道 FileOutputStream fileOutputStream = new FileOutputStream(outfile); FileInputStream fileInputStream1 = new FileInputStream(infile1); FileInputStream fileInputStream2 = new FileInputStream(infile2); //把输入流存储到集合中，然后再从集合中读取 ArrayList&lt;FileInputStream&gt; list = new ArrayList&lt;FileInputStream&gt;(); list.add(fileInputStream1); list.add(fileInputStream2); //准备一个缓冲数据 byte[] buf = new byte[1024]; int length = 0; for(int i=0;i&lt;list.size();i++)&#123; FileInputStream fileInputStream = list.get(i); while ((length=fileInputStream.read(buf))!=-1)&#123; fileOutputStream.write(buf,0,length); &#125; //关闭资源 fileInputStream.close(); &#125; fileOutputStream.close(); &#125;&#125; 把一首mp3先切割成N份，然后再把这些文件合并起来12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class demo&#123; public static void main(String[] args)&#123; //cuteFile(); mergeFile(); &#125; //合并 public static void mergeFile() throws IOException&#123; File dir = new File("e:\\music"); //通过目标文件夹找到所有的MP3文件，然后把所有的MP3文件添加到vector中 Vector&lt;FileInputStream&gt; vector = new Vector&lt;FileInputStream&gt;(); File[] files = dir.listFiles(); for(File file : files)&#123; if(file.getName().endsWith(".mp3"))&#123; vector.add(new FileInputStream(file)); &#125; &#125; //通过Vector获取迭代器 Enumeration&lt;FileInputStream&gt; e = vector.elements(); //创建序列流 SequenceInputStream inputStream = new SequenceInputStream(e); //建立文件的输出通过 FileOutputStream fileOutputStream = new FileOutputStream("e:\\合并.mp3"); //建立缓冲数组读取文件 byte[] buf = new byte[1024]; int length = 0; while((length = inputStream.read(buf))!=-1)&#123; fileOutputStream.write(buf,0,length); &#125; //关闭资源 fileOutputStream.close(); inputStream.close(); &#125; //切割MP3 public static void cutFile() throws IOException&#123; File file = new File("e:\\1.mp3"); File dir = new File("e:\\music"); //建立数据的输入通道 FileInputStream fileInputStream = new FileInputStream(file); //建立缓冲数组读取 byte[] buf = new byte[1024]; int length = 0; for(int i=0;(length = fileInputStream.read(buf))!=-1;i++)&#123; FileOutStream fileOutputStream = new FileOutputStream(new File(dir,"part"+i+".mp3")); fileOutputStream.write(buf,0,length); fileOutputStream.close(); &#125; //关闭资源 fileInputStream.close(); &#125;&#125; 对象输入输出流主要的作用是用于写对象的信息与数据对象的信息，对象一旦写到文件上那么对象的信息就可以做到持久化了 对象的输出流：ObjectOutputStream对象的输入流：ObjectInputStream 注意的细节 如果对象需要被写出到文件上，那么对象所属的类必须要实现Serializable接口，Serializable接口没有任何的方法，是一个标识接口而已 对象的反序列化创建对象的时候并不会调用到构造方法的 serialVersionUID是用于记录class文件的版本信息的，serialVersionUID这个数字是通过一个类的类名、成员、包名、工程名算出的一个数字 使用ObjectInputStream反序列化的时候，ObjectInputStream会先读取文件中的SerialVersionUID，然后与本地class文件的serialVersionUID进行对比，如果这两个id不一致，那么反序列化就失败了 如果序列化与反序列化的时候可能会修改类的成员，那么最好一开始就给这个类指定一个serialVersionUID，如果已经指定的serialVersionUID，后面再序列化与反序列化的时候，jvm都不会再自己算这个class的serialVersionUID了 如果一个对象某个数据不想被序列化到硬盘，可以使用关键字transient修饰 如果一个类维护了另一个类的引用，那么另外一个类也需要实现serializable接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Address implements Serializable&#123; String country; String city; public Address(String country,String city)&#123; this.country = country; this.city = city; &#125;&#125;--------------------------------------------------class User implements Serializable&#123; private static final long serialVersionUID = 1L; String userName; String password; transient int age; //transient 透明 Address address; public User(String userName,String password)&#123; this.userName = userName; this.password = password; &#125; public User(String userName,String password,int age,Address address)&#123; this.userName = userName; this.password = password; this.age = age; this.address = address; &#125; @Override public String toString()&#123; return "用户名:"+this.userName+" 密码:"+this.password+" 年龄:"+this.age+" 地址:"+this.address.city; &#125;&#125;---------------------------------------------------public class demo&#123; public static void main(String[] arg) throws IOException,ClassNotFoundException&#123; readObj(); // writeObj(); &#125; //把文件中的对象信息读取出来-------&gt;对象的反序列化 public static void readObj() throws IOException,ClassNotFoundException &#123; //找到目标文件 File file = new File("E:\\a.txt"); //建立数据的输入通道 FileInputStream fileInputStream = new FileInputStream(file); //建立对象的输入流对象 ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); //读取对象信息 //创建对象肯定要依赖对象所属的class文件 User user = (User) objectInputStream.readObject(); System.out.println("对象的信息："+user); &#125; //定义方法把对象的信息写到硬盘上------&gt; 对象的序列化 public static void writeObj() throws IOException&#123; //把user对象的信息持久化存储 Address address = new Address("中国","广州"); User user = new User("admin","123",15,address); //找到目标文件 File file = new File("e:\\a.txt"); //建立数据输出流对象 FileOutputStream fileOutputStream = new FileOutputStream(file); //建立对象的输出流对象 ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); //把对象写出 objectOutputStream.writeObject(user); //关闭资源 objectOutputStream.close(); &#125;&#125; 配置文件类Properties(配置文件夹)：主要用于生产配置文件与读取配置文件的信息 Properties要注意的细节： 如果配置文件的信息一旦使用了中文，那么在使用store方法生成配置文件的时候只能使用字符流解决，如果使用字节流生成配置文件的话，默认使用的是iso8859-1码表进行编码存储，这时候会出现乱码。 如果Properties中的内容发生了变化，一定要重新使用Properties生产配置文件，否则配置文件信息不会发生变化。 1234567891011121314151617181920212223242526272829303132333435363738public class demo&#123; public static void main(String[] args) throws IOException&#123; createProperties(); // readProperties(); &#125; //读取配置文件的信息 public static void readProperties() throws IOException &#123; //创建Properties对象 Properties properties = new Properties(); //加载配置文件信息到Properties中 properties.load(new FileReader("e:\\2.properties")); //遍历 Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entries = properties.entrySet(); for(Map.Entry&lt;Object,Object&gt; entry:entries)&#123; System.out.println("键："+entry.getKey()+" 值："+entry.getValue()); &#125; //修改狗娃的密码 //把修改后的Properties在生成一个配置文件 properties.setProperty("狗娃","007"); properties.store(new FileWriter("e:\\2.properties"),"haha"); &#125; //保存配置文件的信息 public static void createProperties() throws IOException&#123; //创建Properties Properties properties = new Properties(); properties.setProperty("狗娃","123"); properties.setProperty("狗剩","234"); properties.setProperty("铁蛋","345"); //配置Properties生成配置文件 properties.store(new FileWriter("e:\\2.properties"),"hehe"); &#125;&#125; 使用Properties实现本软件只能运行三次，超过了三次之后就提示购买正版，退出jvm123456789101112131415161718192021222324252627282930313233343536public class demo&#123; public static void main(String[] args)&#123; File file = new File("e:\\3.properties"); if(!file.exists())&#123; //如果配置文件不存在，则创建该配置文件 file.createNewFile(); &#125; //创建Properties对象 Properties properties = new Properties(); //把配置文件的信息加载到properties中 properties.load(new FileInputStream(file)); FileOutputStream fileOutputStream = new FileOutputStream(file); //定义该变量是用于保存软件的运行次数的 int count = 0; //读取配置文件的运行次数 String value = properties.getProperty("count"); if(value!=null)&#123; count = Integer.parseInt(value); &#125; //判断使用的次数是否已经达到了三次 if(count == 3)&#123; System.out.println("你已经超出了试用次数，请购买正版软件！！"); System.exit(0); &#125; count++; System.out.println("你已经使用了本软件第"+count+"次"); properties.setProperty("count",count+"次"); //使用Properties生产一个配置文件 properties.store(fileOutputStream,"runtime"); &#125;&#125; 打印流(printStream) 打印流可以打印任意类型的数据，而且打印数据之前都会先把数据转换成字符串再进行打印 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Animal&#123; String name; String color; public Animal(String name,String color)&#123; this.name = name; this.color = color; &#125; @Override public String toString()&#123; return "名字："+this.name+" 颜色："+this.color; &#125;&#125;---------------------------------------------------public class demo&#123; public static void main(String[] args) throws IOException&#123; FileOutputStream fileOutputStream = new FileOutputStream("e:\\a.txt"); fileOutputStream.write("97".getBytes()); fileOutputStream.close(); //打印流可以打印任何类型的数据，而且打印数据之前都会先把数据转换成字符串再进行打印 File file = new File("e:\\a.txt"); //创建一个打印流 PrintStream printStream = new PrintStream(file); printStream.println(97); printStream.println('a'); printStream.println(true); Animal a = new Animal("老鼠","黑色"); printStream.println(a); //默认标准的输出流就是想控制台输出的 //重新设置了标准的输出流对象 System.setOut(printStream); System.out.println("哈哈，猜猜我在哪里!!"); //收集异常的日志信息 File logFile = new File("e:\\20150108.log"); PrintStream logPrintStream = new PrintStream(new FileOutputStream(logFile)); try&#123; int c = 4/0; System.out.println("c="+c); int[] arr = null; System.out.println(arr.length); &#125;catch(Exception e)&#123; e.printStackTrace(logPrintStream); &#125; &#125;&#125; 编码与解码 编码：把看得懂的字符变成看不懂的码值这个过程我们称为编码 解码：把码值找到对应的字符，我们把这个过程称作为解码 注意：有编码和解码一般我们都使用统一的码表，否则非常容易出乱码 12345678910111213141516171819202122232425262728public class demo&#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = "中国"; //平台默认的编码表是gbk编码表，编码 byte[] buf = str.getBytes("utf-8"); System.out.println("数组的元素:"+Arrays.toString(buf)); //默认使用gbk码表去解码 String str1 = new String(buf,"utf-8"); System.out.println("解码后的字符串："+str1); String str2 = "a中国"; //编码与解码的时候指定的码表是Unicode，世界上就是使用的utf-16 byte[] buf1 = str2.getBytes("unicode"); System.out.println("数组的内容："+Arrays.toString(buf)); String str3 = "大家好"; //使用gbk进行编码 byte[] buf2 = str3.getBytes(); System.out.println("字节数组："+Arrays.toString(buf2)); String str4 = new String(buf2,"iso8859-1"); byte[] buf3 = str4.getByte("iso8859-1"); String str5 = new String(buf3,"gbk"); System.out.println(str5); &#125;&#125; 转换流输入字节流的转换流：InputStreamReader 是字节流通过字节流的桥输出字节流的转换流：OutputStreamWriter 可以把输出字节流转换成输出字符流 转换流的作用： 如果目前所获取到的是一个字节流需要转换字节流使用，这时候就可以转换流。字节流 —&gt; 字符流 使用转换流可以指定编码进行读写文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class demo&#123; public static void main(String[] args) throws IOException&#123; // readTest(); // writeTest(); // writeTest2(); readTest2(); &#125; //使用输入字节流的转换流指定码表进行读取文件数据 public static void readTest2() throws IOException&#123; File file = new File("e:\\b.txt"); FileInputStream fileInputStream = new FileInputStream(file); //创建字节流的转换流并且码表进行读取 InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream); char[] buf = new char[1024]; int length = 0; while((length = inputStreamReader.read(buf))!=-1)&#123; System.out.println(new String(buf,0,length)); &#125; &#125; //使用输出字节流的转换流指定码表写出数据 public static void writeTest2() throws IOException &#123; File file = new File("e:\\c.txt"); //建立数据的输出通道 FileOutputStream fileOutputStream = new FileOutStream(file); //把输出字节流转换字符流并且指定编码表 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream); outputStreamWriter.write("新中国好啊"); //关闭资源 outputStreamWriter.close(); &#125; public statci void writeTest() throws IOException&#123; File file = new File("e:\\b.txt"); FileOutputStream fileOutputStream = new FileOutputStream(file); //把输出字节流转换成输出字符流 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream); outputStreamWriter.write("大家好"); outputStreamWriter.close(); &#125; public static void readTest() throws IOException&#123; //获取了标准的输入流 InputStream in = System.in; //read() 一次只能读取一个字节 //System.out.println("读取到的字符："+(char)in.read()); //需要把字节流转换成字符流 InputStreamReader inputStreamReader = new InputStreamReader(in); //使用字符流的缓冲类 BuffereReader buffereReader = new BuffereReader(inputStreamReader); String line = null; while((line = buffereReader.readline())!=null)&#123; System.out.println("内容："+line); &#125; &#125;&#125; 案例 列出一个文件夹的子孙文件与目录 列出指定目录中所有的子孙文件与子孙目录名，要求名称前面要有相应数据的空格 列出指定目录中所有的子孙文件与子孙目录名，要求是树状结构 删除一个非空的文件夹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class demo&#123; public static void main(String[] args)&#123; File dir = new File("e:\\BaiduYunDownload"); listFile3(dir,"|---"); // File dir = new File("e:\\aa"); // deleteDir(dir); &#125; //删除了一个非空的目录 public static void deleteDir(File dir)&#123; //列出了所有的子文件 File[] files = dir.listFiles(); for(File file:files)&#123; if(file.isFile())&#123; file.delete(); &#125;else if(file.isDirectory())&#123; deleteDir(file); &#125; &#125; dir.delete(); &#125; public static void listFile3(File dir,String space)&#123; //space存储的是空格 File[] files = dir.listFile(); for(File file:files)&#123; if(file.isFile())&#123; System.out.println(space+file.getName()); &#125; else if(file.isDirectory())&#123; System.out.println(space+file.getName()); listFile3(file,"|"+space); &#125; &#125; &#125; //列出一个文件夹的子孙文件与目录 public static void listFile2(File dir,String space)&#123; File[] files = dir.listFiles(); //列出所有的子文件 for(File file:files)&#123; if(file.isFile())&#123; System.out.println(space+file.getName()); &#125;else if(file.isDirectory())&#123; System.out.println(space+file.getName()); listFile2(file," "+space) &#125; &#125; &#125; //列出一个文件夹的子孙文件与目录 public static void listFiles1(File dir)&#123; File[] files = dir.listFiles(); for(File file:files)&#123; if (file.isFile())&#123; System.out.println("文件名:"+file.getName()); &#125;else if(file.isDiretory())&#123; System.out.println("文件夹:"+file.getName()); listFiles1(file); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3格式化输出]]></title>
    <url>%2Fhexo%2F2018%2F12%2F27%2FPython3%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[格式化输出分两种 1. %格式化123456789name = input("请输入你的名字：")age = int(input("请输入你的年龄："))job = input("请输入你的工作：")print("""-----------%s------------ name: %s age: %d job: %s -------------------------""" %(name,name,age,job)) % 代表占位符%s 代表字符串%d 代表数字%% 代表%分号 2. format格式化format格式化又分三种形式 2.1 {}123456789name = input("请输入你的名字：")age = int(input("请输入你的年龄："))job = input("请输入你的工作：")print("""-----------&#123;&#125;------------ name: &#123;&#125; age: &#123;&#125; job: &#123;&#125; -------------------------""".format(name,name,age,job)) 2.2 {n}123456789name = input("请输入你的名字：")age = int(input("请输入你的年龄："))job = input("请输入你的工作：")print("""-----------&#123;0&#125;------------ name: &#123;0&#125; age: &#123;1&#125; job: &#123;2&#125; -------------------------""".format(name,age,job)) #跟第一种相比，重复的元素可以用相同的&#123;n&#125;指定，不需要重复 2.3 {name}123456789name = input("请输入你的名字：")age = int(input("请输入你的年龄："))job = input("请输入你的工作：")print("""-----------&#123;name&#125;------------ name: &#123;name&#125; age: &#123;age&#125; job: &#123;job&#125; -------------------------""".format(name=name,age=age,job=job))]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3运算符]]></title>
    <url>%2Fhexo%2F2018%2F12%2F26%2FPython3%20%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1. 基本运算符+ 加 - 减 * 乘 % 除 ** 幂运算 // 取整 2. 比较运算符== 比较对象是否相等 != 比较对象是否不相等 &lt;&gt; 是否不相等 > 是否大于 &lt; 是否小于 >= 大于等于 &lt;= 小于等于 3. 逻辑运算and 与 x and y x为false则返回x，否则返回yor 或 x or y x为false返回y，否则返回xnot 非 4. 运算符优先级( ) &gt; not &gt; and &gt;or]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github和git设置]]></title>
    <url>%2Fhexo%2F2018%2F12%2F26%2Fgithub%E5%92%8Cgit%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[github仓库在创建的时候可以选择是否初始化，不同的选择对应的Git的操作也是不同的 创建仓库的时候不进行初始化1. 登录Github 2. 创建库 3. 在本地创建git存放的目录并在目录中选择命令行 4. 在命令行中按github给的命令依次输入123456echo "# 库名" &gt;&gt; README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin git@github.com:huaxs119/库名.gitgit push -u origin master 5. 执行成功之后可以看到 6. 需要注意的部分在hosts文件中添加13.250.177.223 github.com 配置ssh密钥如果没有配置会出现如下提示 执行下面的命令cd ~/.sshssh-keygen 打开密钥文件vim ~/.ssh/id_rsa.pub复制密钥配置到github上 在命令行中回到git存放目录执行git push -u origin master 创建仓库的时候进行初始化1. 创建仓库的时候 2. github会自动建好库 3. 将远程库拉回到本地即可 4. 本地创建存放目录并打开命令行 5. 命令行执行clone命令，地址为第三步的ssh地址git clone git@github.com:huaxs119/库名.git]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
